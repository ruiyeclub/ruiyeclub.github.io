<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Compose搭建Redis一主二从三哨兵高可用集群</title>
    <url>/2022/02/10/Compose%E6%90%AD%E5%BB%BARedis%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%E4%B8%89%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="一、Docker-Compose介绍"><a href="#一、Docker-Compose介绍" class="headerlink" title="一、Docker Compose介绍"></a>一、Docker Compose介绍</h2><blockquote>
<p><a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
</blockquote>
<p>Docker官方的网站是这样介绍Docker Compose的：</p>
<p><strong>Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。</strong></p>
<p>这里Docker Compose给我的感受就是便捷、快速。只需编写一个docker-compose.yml文件，然后通过命令docker-compose up -d，这里就可以搭建多个服务起来，非常适合搭建集群环境。</p>
<h2 id="二、安装Docker-Compose工具"><a href="#二、安装Docker-Compose工具" class="headerlink" title="二、安装Docker Compose工具"></a>二、安装Docker Compose工具</h2><p>通过命令安装Compose工具，安装Compose的前提是安装了Docker环境，如何安装和快速使用Docker，可以翻看我之前的那篇博客–<a href="Docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B9%8B%E6%90%AD%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE"></a>，这里不做赘述了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>给安装脚本添加执行权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>这里可以使用命令查看是否安装成功</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>
<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/51ea38aadbb2ff6e09252ef863d8b8ef.png" alt="image.png"><br>到这里Compose工具就安装好了</p>
<h2 id="三、使用Compose搭建Redis主从服务器"><a href="#三、使用Compose搭建Redis主从服务器" class="headerlink" title="三、使用Compose搭建Redis主从服务器"></a>三、使用Compose搭建Redis主从服务器</h2><p><strong>主从复制</strong>：主节点负责写数据，从节点负责读数据，主节点定期把数据同步到从节点保证数据的一致性。</p>
<p>从性能方面，redis复制功能增加了读的性能，理论上说，每增加一倍的服务器，整个系统的读能力就增加一倍。</p>
<p>选择好路径，通过命令创建文件夹redis，然后进入文件夹创建docker-compose.yml，或者在本地创建，然后通过Xftp工具上传至服务器。docker-compose.yml写入如下内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  master:</span><br><span class="line">    image: redis　　　　## 镜像</span><br><span class="line">    container_name: redis-master　　　　##容器别名</span><br><span class="line">    command: redis-server --requirepass 123456　　　　##redis密码</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;6379:6379&quot;　　　　##暴露端口</span><br><span class="line">    networks:</span><br><span class="line">    - sentinel-master</span><br><span class="line">  slave1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-slave-1</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;6380:6379&quot;</span><br><span class="line">    command: redis-server --slaveof redis-master 6379 --requirepass 123456 --masterauth 123456 </span><br><span class="line">    depends_on:</span><br><span class="line">    - master</span><br><span class="line">    networks:</span><br><span class="line">    - sentinel-master</span><br><span class="line">  slave2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-slave-2</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;6381:6379&quot;</span><br><span class="line">    command: redis-server --slaveof redis-master 6379 --requirepass 123456 --masterauth 123456</span><br><span class="line">    depends_on:</span><br><span class="line">    - master</span><br><span class="line">    networks:</span><br><span class="line">    - sentinel-master</span><br></pre></td></tr></table></figure>
<p>启动redis集群</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>docker ps查看运行的实例，这里我们需要用到主节点的ip地址，注意不是电脑的ip哦，是节点的ip地址。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker inspect 主节点容器id</span><br></pre></td></tr></table></figure>
<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/53f49345df59e36ee71202f08c7f8d94.png" alt="image.png"><br>这里先记着这个ip地址，后面使用到哨兵需要绑定这个主节点的ip。</p>
<h2 id="四、哨兵sentinel模式搭建"><a href="#四、哨兵sentinel模式搭建" class="headerlink" title="四、哨兵sentinel模式搭建"></a>四、哨兵sentinel模式搭建</h2><p>上面我们已经搭建好了主从模式，当主服务器宕机后，需要手动把一台服务器切换成主服务器，这里需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。<br>哨兵是redis高可用的解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及这些主服务器属下的所有从服务器，它能够在被监视的主服务器下线时，自动将该主服务器属下的某个优先的从服务器升级为新的主服务器，由这个主服务器代替已下线的主服务器继续处理命令请求。</p>
<p>哨兵的功能：<br>1.监控：哨兵会不断地监控检测主节点和从节点是否运作正常。<br>2.自动故障转移：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。<br>3.通知：哨兵可以将故障转移的结果发送给客户端。<br>4.配置提供者：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</p>
<p>这里创建sentinel文件夹，然后同样编写docker-compose.yml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  sentinel1:</span><br><span class="line">    image: redis       ## 镜像</span><br><span class="line">    container_name: redis-sentinel-1</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;26379:26379&quot;</span><br><span class="line">    command: redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">    - &quot;./sentinel.conf:/usr/local/etc/redis/sentinel.conf&quot;</span><br><span class="line">  sentinel2:</span><br><span class="line">    image: redis                ## 镜像</span><br><span class="line">    container_name: redis-sentinel-2</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;26380:26379&quot;           </span><br><span class="line">    command: redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">    - &quot;./sentinel2.conf:/usr/local/etc/redis/sentinel.conf&quot;</span><br><span class="line">  sentinel3:</span><br><span class="line">    image: redis                ## 镜像</span><br><span class="line">    container_name: redis-sentinel-3</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;26381:26379&quot;           </span><br><span class="line">    command: redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">    - ./sentinel3.conf:/usr/local/etc/redis/sentinel.conf</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: redis_sentinel-master</span><br></pre></td></tr></table></figure>
<p>继续在此目录编写文件，编写sentinel.conf文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line">#172.18.0.3填写自己的主节点ip</span><br><span class="line">sentinel monitor mymaster 172.18.0.3 6379 2</span><br><span class="line">sentinel auth-pass mymaster 123456 </span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 10000  </span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br></pre></td></tr></table></figure>
<p>对命令的解释</p>
<blockquote>
<p>第三行表示Redis监控一个叫做mymaster的运行在172.18.0.3:6379的master，投票达到2则表示master以及挂掉了。<br>第四行设置主节点的密码。<br>第五行表示在一段时间范围内sentinel向master发送的心跳PING没有回复则认为master不可用了。<br>第六行的parallel-syncs表示设置在故障转移之后，同时可以重新配置使用新master的slave的数量。数字越低，更多的时间将会用故障转移完成，但是如果slaves配置为服务旧数据，你可能不希望所有的slave同时重新同步master。因为主从复制对于slave是非阻塞的，当停止从master加载批量数据时有一个片刻延迟。通过设置选项为1，确信每次只有一个slave是不可到达的。<br>第七行表示10秒内mymaster还没活过来，则认为master宕机了。</p>
</blockquote>
<p>创建好文件后，复制好三份</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cp sentinel.conf sentinel1.conf</span><br><span class="line">cp sentinel.conf sentinel2.conf</span><br><span class="line">cp sentinel.conf sentinel3.conf</span><br></pre></td></tr></table></figure>
<p>启动redis哨兵模式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h2 id="五、故障转移测试"><a href="#五、故障转移测试" class="headerlink" title="五、故障转移测试"></a>五、故障转移测试</h2><p>上面既然说到了哨兵可以自动转移故障，也就是当主节点宕机的时候，它们能通过选举制度，在从节点中选出一个节点来代替主节点。</p>
<p>我们先来看看主节点此时的信息，这里a288c55db497是我主节点容器的ip，这里先是进入容器，再进入redis客户端，再输入密码，然后使用info查看节点信息。<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/b78632e11091376763eb17eb0a456666.png" alt="image.png"><br>这里可以看到这个节点的身份是master也就是主节点，然后有两个连接着的从节点<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/29b59a2b56a62e32552c35bf626817e4.png" alt="image.png"></p>
<p>现在我们停掉这个节点，看看哨兵是否可以实现故障转移</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker stop a288c55db497</span><br></pre></td></tr></table></figure>
<p>然后选择其中一个从节点进入客户端，输入info查看信息<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/81c6dc9c59ee6ff27dd01d9aabad7827.png" alt="image.png"><br>这里发现其中一台从节点已经变成主节点了，而且连接的从节点，也变成了一个。</p>
<p>了解Docker Compose可参考：<a href="https://www.jianshu.com/p/658911a8cff3">https://www.jianshu.com/p/658911a8cff3</a></p>
<p>了解Redis主从哨兵可参考：<a href="https://www.cnblogs.com/leeSmall/p/8398401.html">https://www.cnblogs.com/leeSmall/p/8398401.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Docker快速上手之部署SpringBoot项目</title>
    <url>/2022/02/01/Docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B9%8B%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><strong>Docker是基于Go语言实现的云开源项目。</strong></p>
<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/2db39f1e0972b7dd1557c891d9300fdd.png" alt="image.png"><br>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p>
<h4 id="一、我所理解的Docker"><a href="#一、我所理解的Docker" class="headerlink" title="一、我所理解的Docker"></a>一、我所理解的Docker</h4><blockquote>
<p>我喜欢将Docker比喻成”方便面”，为什么说是方便面，之前部署项目环境的配置十分麻烦，换一台机器，就要重来一次，费力费时。举个栗子，我们部署一个SpringBoot项目，我们需要在服务器上面配置项目的运行环境，要安装各种各样的软件JDK&#x2F;MySQL&#x2F;Redis&#x2F;nginx，安装和配置这些东西十分麻烦，下次需要换个服务器重新部署又得重新安装一遍，简直要命。而Docker能将项目连带着运行环境一同部署过去，就好像泡面，泡面所需的调料包还有工具都附加在了里面。一句话总结Docker的好处，Docker解决了运行环境和配置问题，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
</blockquote>
<h4 id="二、Docker与虚拟机的区别"><a href="#二、Docker与虚拟机的区别" class="headerlink" title="二、Docker与虚拟机的区别"></a>二、Docker与虚拟机的区别</h4><table>
<thead>
<tr>
<th></th>
<th>Docker容器</th>
<th>虚拟机（VM）</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>宿主机OS上运行虚拟机OS</td>
</tr>
<tr>
<td>存储大小</td>
<td>镜像小，便于存储与传输</td>
<td>镜像庞大（vmdk、vdi等）</td>
</tr>
<tr>
<td>运行性能</td>
<td>几乎无额外性能损失</td>
<td>操作系统额外的CPU、内存消耗</td>
</tr>
<tr>
<td>移植性</td>
<td>轻便、灵活，适用于Linux</td>
<td>笨重，与虚拟化技术耦合度高</td>
</tr>
<tr>
<td>硬件亲和性</td>
<td>面向软件开发者</td>
<td>面向硬件运维者</td>
</tr>
</tbody></table>
<h4 id="三、Docker里面三个重要的概念Dockerfile、镜像-image-、容器-Container"><a href="#三、Docker里面三个重要的概念Dockerfile、镜像-image-、容器-Container" class="headerlink" title="三、Docker里面三个重要的概念Dockerfile、镜像(image)、容器(Container)"></a>三、Docker里面三个重要的概念Dockerfile、镜像(image)、容器(Container)</h4><p>1.Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<p>Dockerfile体系结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">FROM　　基础镜像，当前新镜像是基于哪个镜像的</span><br><span class="line">MAINTAINER　　镜像维护者的姓名和邮箱地址</span><br><span class="line">RUN　　容器构建时需要运行的命令</span><br><span class="line">EXPOSE　　当前容器对外暴露出的端口</span><br><span class="line">WORKDIR　　指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</span><br><span class="line">ENV　　用来在构建镜像过程中设置环境变量</span><br><span class="line">AD　　将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span><br><span class="line">COPY　　类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中<span class="tag">&lt;<span class="name">源路径</span>&gt;</span>的文件/目录复制到新的一层的镜像内的<span class="tag">&lt;<span class="name">目标路径</span>&gt;</span>位置</span><br><span class="line">VOLUME　　容器数据卷，用于数据保存和持久化工作</span><br><span class="line">CMD　　指定一个容器启动时要运行的命令。Dockerfile中可以有多个CMD指令，但只要最后一个生效，CMD会被docker run之后的参数替换</span><br><span class="line">ENTRYPOINT　　指定一个容器启动时要运行的命令。ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数</span><br><span class="line">ONBUILD　　当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</span><br></pre></td></tr></table></figure>
<p>2.镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>3.容器是用镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的Linux环境（包括root用户权限、用户空间和网络空间等）和运行在其中的应用程序。</p>
<h4 id="四、安装Docker"><a href="#四、安装Docker" class="headerlink" title="四、安装Docker"></a>四、安装Docker</h4><p>1.安装Docker依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>2.设置阿里云镜像源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">```xml</span><br><span class="line">3.安装 Docker-CE</span><br><span class="line">```xml</span><br><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure>
<p>4.查看是否安装成功</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/3d0de6d7f169b639389384e8184829f5.png" alt="image.png"></p>
<h4 id="五、使用Docker安装MySQL"><a href="#五、使用Docker安装MySQL" class="headerlink" title="五、使用Docker安装MySQL"></a>五、使用Docker安装MySQL</h4><p>1.使用Docker拉取Mysql镜像(这里安装的是MySQL5.6版本)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure>
<p>2.安装mysql命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql -v /ray/mysql/conf:/etc/mysql/conf.d -v /ray/mysql/logs:/logs -v /ray/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql:5.7</span><br></pre></td></tr></table></figure>
<p>命令说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-p <span class="number">3306</span>:<span class="number">3306</span>　　将主机的<span class="number">3306</span>端口映射到docker容器的<span class="number">3306</span>端口</span><br><span class="line">--name mysql　　运行服务器名字</span><br><span class="line">-v /ray/mysql/conf:/etc/mysql/conf.d　　将主机/ray/mysql目录下的conf/my.cnf挂载到容器的/etc/mysql/conf.d</span><br><span class="line">-v /ray/mysql/logs:/logs　　将主机/ray/mysql目录下的logs目录挂载到容器的/logs</span><br><span class="line">-v /ray/mysql/data:/<span class="keyword">var</span>/lib/mysql　　将主机/ray/mysql目录下的data目录挂载到容器的/<span class="keyword">var</span>/lib/mysql</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=admin　　初始化root用户的密码</span><br><span class="line">-d mysql:<span class="number">5.7</span>　　后台程序运行mysql5<span class="number">.7</span></span><br></pre></td></tr></table></figure>
<p>3.进入mysql</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker exec -it MySQL运行成功后的容器ID /bin/bash</span><br></pre></td></tr></table></figure>
<p>然后即可登录MySQL，创建数据库，或者使用Navicat等工具创建数据库。</p>
<h4 id="六、使用Docker安装Redis"><a href="#六、使用Docker安装Redis" class="headerlink" title="六、使用Docker安装Redis"></a>六、使用Docker安装Redis</h4><p>1.使用Docker拉取Redis镜像(这里安装的是Redis3.2版本)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker pull redis:3.2</span><br></pre></td></tr></table></figure>
<p>2.安装redis命令(这里不对命令做解释)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 -v /ray/redis/data:/data -v /ray/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<h4 id="七、Docker部署SpringBoot项目"><a href="#七、Docker部署SpringBoot项目" class="headerlink" title="七、Docker部署SpringBoot项目"></a>七、Docker部署SpringBoot项目</h4><p>1.将项目打包成jar包(假设名字为myblog.jar)，并编写一个Dockerfile文件，文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Docker image for springboot file run</span><br><span class="line"># VERSION 0.0.1</span><br><span class="line"># Author: Ray</span><br><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER Ray &lt;185048761@qq.com&gt;</span><br><span class="line"># VOLUME 指定了临时文件目录为/tmp。</span><br><span class="line"># 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为app.jar</span><br><span class="line">ADD myblog.jar app.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#x27;touch /app.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br><span class="line">#暴露8080端口</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>
<p>2.将这两个文件一并上传至服务器中的同一个目录下面，进入该文件夹后执行此命令构建镜像：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/f175e9402c4d4bf3e98c78f055b6e9c6.png" alt="image.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker build -t myblog.jar .</span><br></pre></td></tr></table></figure>
<p>3.生成docker容器，并运行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 myblog.jar</span><br></pre></td></tr></table></figure>
<p>等一会儿，SpringBoot项目跑起来了后，就可以使用浏览器通过80端口进行访问了</p>
]]></content>
  </entry>
  <entry>
    <title>Idea使用插件实现逆向工程搭建SpringBoot项目</title>
    <url>/2022/02/07/Idea%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>之前写SpringBoot项目，每次都要手动去写实体类、dao层啥的，尤其是数据库表字段特别多的时候，特别麻烦。然后很多小伙伴都会用逆向工程来自动生成这些类，省去许多没必要的代码量，但是Mybatis的逆向工程依然需要配置，导逆向工程的jar啊，还有编写generatorConfig.xml文件啊（有兴趣的朋友可以看看这篇<a href="%E5%8D%9A%E5%AE%A2"></a>）。今天逛gitee的时候，看到了一款可以免去许多配置的idea逆向工程插件，几个步骤简单使用一下</p>
<p>这个插件。<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/03211e75a42c7cdfb6feeae5e6e72104.png" alt="image.png"></p>
<h3 id="一、下载并安装EasyCode插件"><a href="#一、下载并安装EasyCode插件" class="headerlink" title="一、下载并安装EasyCode插件"></a>一、下载并安装EasyCode插件</h3><p>Setting-&gt;Plugins。搜索EasyCode插件，并重启Idea编辑器<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/adb271ad8f16d31f54fe857f62466897.png" alt="image.png"></p>
<h3 id="二、配置MYSQL数据源"><a href="#二、配置MYSQL数据源" class="headerlink" title="二、配置MYSQL数据源"></a>二、配置MYSQL数据源</h3><p>点击Idea右侧的Database，然后再点一下加号，选择你的数据库类型，我这里选择的是MySQL<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/867fa36ed0e166104a784b39b6313f1f.png" alt="image.png"></p>
<h3 id="三、配置连接参数"><a href="#三、配置连接参数" class="headerlink" title="三、配置连接参数"></a>三、配置连接参数</h3><p>配置好自己的数据库连接参数后，点击Apply，然后再点击Schemas选择使用哪个数据库<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/9cebd4ceea4ccbfea4a7bd42cd6b01af.png" alt="image.png"></p>
<h3 id="四、生成代码"><a href="#四、生成代码" class="headerlink" title="四、生成代码"></a>四、生成代码</h3><p>如图，点击Generate Code<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/c3b18d5697e490ecb39f5d99b8a759b9.png" alt="image.png"><br>这里选择项目模块，还有需要生成的代码<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/eb737e2b3d63f054f9d07b36805cfe6f.png" alt="image.png"><br>生成后的目录就这个样子，里面还写好了单表的CRUD操作<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/17c05c5e193dc89a1409c742da29680e.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Idea开发必装插件</title>
    <url>/2022/07/27/Idea%E5%BC%80%E5%8F%91%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>＂工欲善其事必先利其器＂，分享一下我工作中必备的Idea开发插件</p>
</blockquote>
<h3 id="1-Alibaba-Java-Coding-Guidelines"><a href="#1-Alibaba-Java-Coding-Guidelines" class="headerlink" title="1.Alibaba Java Coding Guidelines"></a>1.Alibaba Java Coding Guidelines</h3><blockquote>
<p>我们很高兴推出阿里巴巴 Java 编码指南，它整合了阿里巴巴集团技术团队多年来的最佳编程实践。大量的 Java 编程团队对跨项目的代码质量提出了苛刻的要求，因为我们鼓励重用和更好地理解彼此的程序。过去我们见过很多编程问题。例如，有缺陷的数据库表结构和索引设计可能会导致软件架构缺陷和性能风险。另一个例子是难以维护的混乱代码结构。此外，未经身份验证的易受攻击的代码很容易受到黑客的攻击。为了解决这些问题，我们为阿里巴巴的 Java 开发人员编写了这份文档。</p>
</blockquote>
<p>阿里巴巴代码规范检查插件，有助于我们的代码更加规范。</p>
<h3 id="2-ignore"><a href="#2-ignore" class="headerlink" title="2.ignore"></a>2.ignore</h3><p>忽略Git不必要提交的文件</p>
<h3 id="3-Codota-Ai"><a href="#3-Codota-Ai" class="headerlink" title="3.Codota Ai"></a>3.Codota Ai</h3><p>适用于Java和JavaScript的Codota AI自动补全代码插件</p>
<blockquote>
<p><a href="https://www.codota.com/">Codota</a>基于数百万个开源 Java 程序和您的上下文完成代码行，帮助您更快地编写代码并减少错误。新版 Codota 提供以下功能：</p>
</blockquote>
<ul>
<li>全线AI自动完成</li>
<li>行内和相关的代码示例</li>
<li>基于您自己的编码实践的代码建议</li>
</ul>
<h3 id="4-Easy-Code"><a href="#4-Easy-Code" class="headerlink" title="4.Easy Code"></a>4.Easy Code</h3><blockquote>
<p>EasyCode是基于IntelliJ IDEA Ultimate版开发的一个代码生成插件，主要通过自定义模板（基于velocity）来生成各种你想要的代码。通常用于生成Entity、Dao、Service、Controller。如果你动手能力强还可以用于生成HTML、JS、PHP等代码。理论上来说只要是与数据有关的代码都是可以生成的。</p>
</blockquote>
<h3 id="5-JavaDoc"><a href="#5-JavaDoc" class="headerlink" title="5.JavaDoc"></a>5.JavaDoc</h3><p>快速生成javadoc文档注释</p>
<h3 id="6-Lombok"><a href="#6-Lombok" class="headerlink" title="6.Lombok"></a>6.Lombok</h3><p>主要用途是提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码，提高编码效率，使代码更简洁。</p>
<h3 id="7-MyBatisPlus"><a href="#7-MyBatisPlus" class="headerlink" title="7.MyBatisPlus"></a>7.MyBatisPlus</h3><blockquote>
<p>generator code<br>live template<br>MybatisPlus plugin from java to xml or from xml to java</p>
</blockquote>
<h3 id="8-Nyan-Progress-Bar"><a href="#8-Nyan-Progress-Bar" class="headerlink" title="8.Nyan Progress Bar"></a>8.Nyan Progress Bar</h3><blockquote>
<p>Pretty progress bars with nyan cat for IJ based IDEs.</p>
</blockquote>
<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/picgo/image-20220727142237704.png" alt="Nyan Progress Bar"></p>
<h3 id="9-One-Dark-theme"><a href="#9-One-Dark-theme" class="headerlink" title="9.One Dark theme"></a>9.One Dark theme</h3><p>其中One Dark Vivid主题真的很简洁、舒服，看腻了Idea自带的系统，可以考虑换个主题试试。</p>
<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/picgo/image-20220727143552405.png" alt="One Dark Vivid"></p>
<h3 id="10-Translation"><a href="#10-Translation" class="headerlink" title="10.Translation"></a>10.Translation</h3><blockquote>
<p>Translation plugin for IntelliJ based IDEs&#x2F;Android Studio&#x2F;HUAWEI DevEco Studio.</p>
</blockquote>
<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/picgo/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f596969477578696e672f5472616e736c6174696f6e506c7567696e406d61737465722f696d616765732f73637265656e73686f74732e676966.gif" alt="translation"></p>
<h3 id="11-其他"><a href="#11-其他" class="headerlink" title="11.其他"></a>11.其他</h3><p>Python、requirements等开发python的插件，让我可以更方便的在Idea中编写python代码。</p>
]]></content>
  </entry>
  <entry>
    <title>JVM基础快速入门篇</title>
    <url>/2022/01/31/JVM%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<p><strong>Java是一门可以跨平台的语言，但是Java本身是不可以实现跨平台的，需要JVM实现跨平台。javac编译好后的class文件，在Windows、Linux、Mac等系统上，只要该系统安装对应的Java虚拟机，class文件都可以运行。达到”一次编译，到处运行”的效果。</strong></p>
<h2 id="一、JVM是什么？"><a href="#一、JVM是什么？" class="headerlink" title="一、JVM是什么？"></a>一、JVM是什么？</h2><p>而JVM到底是什么呢？引用百度百科对JVM的介绍：</p>
<blockquote>
<p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
</blockquote>
<h2 id="二、JVM架构知识"><a href="#二、JVM架构知识" class="headerlink" title="二、JVM架构知识"></a>二、JVM架构知识</h2><p>1.JVM主要包含<strong>类装载器、运行时数据区（内存模型）、执行引擎</strong>。里面内存模型有可以细分包括本地方法栈、堆、栈（线程）、方法区（元空间）、程序计数器。<br>如图所示：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/351bc7933dbca9d91c52db9f79bec760.png" alt="image.png"></p>
<p>1.类装载器的作用就是负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎（Execution Engine）决定。类加载器又有四大类加载器：</p>
<p>启动类加载器（Bootstrap ClassLoader）:负责加载JRE核心类库，像JRE中的rt.jar等（C&#x2F;C++）；</p>
<p>扩展类加载器（Extension ClassLoader）：负责加载JRE扩展目录ext中的jar包；</p>
<p>系统类加载器（Application ClassLoader）：负责加载ClassPath路径下的类包；</p>
<p>自定义的类加载器（User ClassLoader）：只加载指定目录下的jar和class，想加载其它位置的类或jar时得自行定义类加载器；</p>
<p>2.<strong>JVM中，对象都是在堆中分配内存空间的，栈只用于保存局部变量和临时变量，如果是对象，只保存引用</strong>，实际内存还是在堆中。栈的特点是先进后出，假设一个main方法，里面执行了一个方法，我们是后执行的那个方法即那个线程，但是执行完毕后，那个线程是先销毁的。<strong>每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表（存放局部变量的）、操作数栈（存放需要运算的数据）、动态链接、方法出口（执行完方法 回到main方法的位置）等信息</strong>，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。即一个方法对应一块栈帧内存区域（存放本方法的局部变量）。</p>
<p>3.方法区存储已被虚拟机加载的类信息、常量（堆中的对象常量地址）、静态变量、即时编译器编译后的代码等数据。</p>
<p>4.本地方法栈和栈的作用类似，但是它服务的对象是native方法，该方法得由c语言来实现。</p>
<p>5.程序计数器作用是当CPU多线程切换的时候，切回到当前线程的时候，回到程序计数器计数的位置，继续执行。</p>
<h2 id="三、堆内存的结构模型"><a href="#三、堆内存的结构模型" class="headerlink" title="三、堆内存的结构模型"></a>三、堆内存的结构模型</h2><p>新生代包括Eden加上2个survivor区，执行minor gc之后，大多数的对象会被回收，活着的进入s0，再次minor gc，活着的对象eden+s0-&gt;s1，再次minor gc，eden+s1-&gt;s0…这里虚拟机采取了分代收集的思想来管理内存，JVM给每个对象一个对象年龄计数器，分代年龄达到15后即对象被执行了15次minor gc后移入老年代。除此之外，s区装不下的大对象也会直接进入老年代。</p>
<p>最后，老年代存的就是一些大对象和需要连续内存空间的对象（静态变量、缓存、线程池等），老年代满了的话，会执行Full GC垃圾收集。官网对Full GC的解释中介绍了个词”Stop-The-World”，它会把所有的应用线程停掉，这时候系统会卡掉。<strong>JVM虚拟机调优的目标就是减少full gc即减少STW。</strong><br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/a79e182e285aa8a998b64f8c2929cea2.png" alt="image.png"></p>
<h2 id="四、垃圾回收机制"><a href="#四、垃圾回收机制" class="headerlink" title="四、垃圾回收机制"></a>四、垃圾回收机制</h2><p><strong>堆里面存放new的对象和数组</strong>，Java优于其他语言一个很重要的原因就是它能自动处理垃圾对象，也就是有垃圾回收机制（GC）。有了垃圾回收机制有几点好处编程简单，系统不容易出错。</p>
<p>1.什么是垃圾？</p>
<p><strong>我们把没有任何引用指向的对象或者一堆对象（循环引用）定义为垃圾。</strong></p>
<p>2.系统如何定位垃圾</p>
<ul>
<li>引用计数算法-简单且高效但是主流的Java虚拟机里并没有选用引用计数算法来管理内存，因为它不能解决循环引用的问题。</li>
<li><strong>根可达分析算法</strong>-将”GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象。线程栈的本地变量、静态变量、本地方法栈的变量等等都可以称作GC Roots跟节点。<br>如图：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/313951e066caf10cfb67e43c4a5a6dcc.png" alt="image.png"></li>
</ul>
<p>3.常见的垃圾回收算法</p>
<ul>
<li><strong>复制算法</strong>-没有碎片 浪费内存空间（目前使用新生代使用的是复制算法）</li>
<li>标记清除-位置不连续 产生内存碎片</li>
<li>标记压缩-没有碎片 效率偏低<br>复制算法它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li>
</ul>
<h2 id="五-常见垃圾回收器"><a href="#五-常见垃圾回收器" class="headerlink" title="五.常见垃圾回收器"></a>五.常见垃圾回收器</h2><p>新生代收集器：Serial、ParNew、Parallel Scavenge<br>老年代收集器：CMS、Serial Old、Parallel Old<br>整堆收集器： G1</p>
<p><strong>jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程(三)：ReentrantLock</title>
    <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%89)%EF%BC%9AReentrantLock/</url>
    <content><![CDATA[<p>ReentrantLock是可以用来代替synchronized的。ReentrantLock比synchronized更加灵活，功能上面更加丰富，性能方面自synchronized优化后两者性能没有什么太大差别。</p>
<p>说一下两者的区别首先ReetrantLock是基于JDK实现层面的，而synchronized是基于JVM层面实现的。ReentrantLock可以进行tryLock尝试锁定，支持公平锁的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务逻辑  </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 一个ReentrantLock的简单实现，要注意的是，必须要手动释放锁，不然很容易产生死锁。使用sync锁定的话遇到异常，jvm会自动释放锁，但是reentrantLock必须手动释放锁，因此经常在finally中进行锁的释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">boolean</span> locked=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked=lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock可以进行tryLock尝试锁定，tryLock的方法就是进行尝试锁定，如果能在指定时间内得到锁，就返回true，反之返回false。指定时间内无法锁定时，线程可以决定是否继续等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//参数为true表示公平锁</span></span><br></pre></td></tr></table></figure>
<p>ReentrantLock可以指定为公平锁，ReentrantLock和sync默认是非公平锁，<strong>非公平锁</strong>：线程加锁时<strong>直接尝试获取锁</strong>，获取不到就自动到队尾等待。而<strong>公平锁</strong>：加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，<strong>先来先得</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程(一)：线程基础知识以及synchronized关键字</title>
    <url>/2022/02/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8Asynchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>1.线程与多线程的概念：在一个程序中，能够独立运行的程序片段叫作“<em>线程</em>”（Thread）。<em>多线程</em>（multithreading）是指从软件或者硬件上实现多个线程并发执行的技术。</p>
<p>2.多线程的意义：多线程可以在时间片里被cpu快速切换，资源能更好被调用、程序设计在某些情况下更简单、程序响应更快、运行更加流畅。</p>
<p>2.如何启动一个线程：继承Thread类、实现Runnable接口、实现Callable接口</p>
<p>3.为什么要保证线程的同步？：java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<p>4.基本的线程同步：使用<em>synchronized</em>关键字、特殊域变量volatile、wait和notify方法等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="comment">//任何线程要执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设这段代码中有多个线程，当第一个线程执行到m方法来的时候，sync锁住了堆内存中的o对象，这个时候第二个线程是进不来的，它必须等第一个线程执行完，锁释放掉才可以接着执行。这里有个锁的概念叫做互斥锁，sync是一种<em>互斥锁</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里等同于synchronized(T3.class)</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (T1.class)&#123;</span><br><span class="line">            <span class="comment">//思考：这里写成synchronized(this)是否可以？</span></span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考这里，注意sync修饰的是一个静态方法和静态的属性，静态修饰的方法和属性是不需要new出对象来就可以访问的，所以这里没有new出对象，sync锁定的是T3.class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        T2 t=<span class="keyword">new</span> <span class="title class_">T2</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(t,<span class="string">&quot;THREAD&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中开启了五个线程，执行run方法对count进行减一的操作，这里会出现线程抢占资源的问题。当第一个线程在执行run方法时，减减的过程中，第二个线程也进入了方法，同样也在执行减减，可能会出现第二个线程减完的时候，第一个线程才输出count，这时候就出现了线程重入。处理方法可以加上synchronized关键字，只有等第一个线程执行完毕，第二个线程才可以进入，即同一时刻只能有一个线程来对它进行操作，也就是<em>原子性</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号持有人和账号余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置账号余额，线程睡眠目的是先让它读数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name,<span class="type">double</span> balance)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance=balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account a=<span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;a.set(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">100.0</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a.getBalance(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a.getBalance(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个小demo，代码中只对set方法加了锁，没有对get方法加锁，这个时候会出现<em>脏读</em>现象。解决方法是读和写的方法都加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例中，m1和m2方法都已经加上了锁，当执行m1的时候再去执行m2，这样是可以的。一个同步方法可以调用另外一个同步方法，也就是说sync获得的锁是<em>可重入锁</em>。还有个概念是<em>死锁</em>，死锁是指多个线程抢占资源而造成的一种互相等待。举个例子，一个箱子需要两把钥匙才可以打开，钥匙分别在两个人手中，这两个人互相抢占另外一个人的钥匙，导致箱子打不开。</p>
]]></content>
  </entry>
  <entry>
    <title>Java并发编程(四)：并发容器(转)</title>
    <url>/2022/02/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E5%9B%9B)%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8(%E8%BD%AC)/</url>
    <content><![CDATA[<p>解决并发情况下的容器线程安全问题的。给多线程环境准备一个线程安全的容器对象。<br>线程安全的容器对象: Vector, Hashtable。线程安全容器对象，都是使用synchronized 方法实现的。concurrent包中的同步容器，大多数是使用系统底层技术实现的线程安全。类似native。Java8 中使用 CAS。</p>
<h2 id="1、Map-Set"><a href="#1、Map-Set" class="headerlink" title="1、Map&#x2F;Set"></a>1、Map&#x2F;Set</h2><h3 id="1-1-ConcurrentHashMap-ConcurrentHashSet"><a href="#1-1-ConcurrentHashMap-ConcurrentHashSet" class="headerlink" title="1.1 ConcurrentHashMap&#x2F;ConcurrentHashSet"></a>1.1 ConcurrentHashMap&#x2F;ConcurrentHashSet</h3><p>底层哈希实现的同步 Map(Set)。效率高，线程安全。使用系统底层技术实现线程安全。 量级较 synchronized 低。key 和 value 不能为 null。</p>
<h3 id="1-2-ConcurrentSkipListMap-ConcurrentSkipListSet"><a href="#1-2-ConcurrentSkipListMap-ConcurrentSkipListSet" class="headerlink" title="1.2 ConcurrentSkipListMap&#x2F;ConcurrentSkipListSet"></a>1.2 ConcurrentSkipListMap&#x2F;ConcurrentSkipListSet</h3><p>底层跳表(SkipList)实现的同步 Map(Set)。有序，效率比 ConcurrentHashMap 稍低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_01_ConcurrentMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        final Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();</span></span><br><span class="line">         <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">         <span class="comment">//ConcurrentSkipListMap跳表实现的，是排序的，最慢</span></span><br><span class="line"><span class="comment">//         final Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Thread[] array = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(array.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;key&quot;</span> + r.nextInt(<span class="number">100000</span>), <span class="string">&quot;value&quot;</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : array) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间为 ： &quot;</span> + (end - begin) + <span class="string">&quot;毫秒！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h2><h3 id="2-1-CopyOnWriteArrayList"><a href="#2-1-CopyOnWriteArrayList" class="headerlink" title="2.1 CopyOnWriteArrayList"></a>2.1 CopyOnWriteArrayList</h3><p>写时复制集合。写入效率低，读取效率高。每次写入数据，都会创建一个新的底层数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_02_CopyOnWriteList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//         final List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        final List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Thread[] array = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(array.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        list.add(<span class="string">&quot;value&quot;</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : array) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间为 ： &quot;</span> + (end - begin) + <span class="string">&quot;毫秒！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List.size() : &quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、Queue"><a href="#3、Queue" class="headerlink" title="3、Queue"></a>3、Queue</h2><h3 id="3-1-ConcurrentLinkedQueue"><a href="#3-1-ConcurrentLinkedQueue" class="headerlink" title="3.1 ConcurrentLinkedQueue"></a>3.1 ConcurrentLinkedQueue</h3><p>基础链表同步队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - ConcurrentLinkedQueue</span></span><br><span class="line"><span class="comment"> * 队列 - 链表实现的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_03_ConcurrentLinkedQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            queue.offer(<span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// peek() -&gt; 查看queue中的首数据</span></span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll() -&gt; 获取queue中的首数据</span></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-LinkedBlockingQueue"><a href="#3-2-LinkedBlockingQueue" class="headerlink" title="3.2 LinkedBlockingQueue"></a>3.2 LinkedBlockingQueue</h3><p>阻塞队列，队列容量不足自动阻塞，队列容量为 0 自动阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - LinkedBlockingQueue</span></span><br><span class="line"><span class="comment"> * 阻塞容器。</span></span><br><span class="line"><span class="comment"> * put &amp; take - 自动阻塞。</span></span><br><span class="line"><span class="comment"> * put自动阻塞， 队列容量满后，自动阻塞</span></span><br><span class="line"><span class="comment"> * take自动阻塞方法， 队列容量为0后，自动阻塞。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_04_LinkedBlockingQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test_04_LinkedBlockingQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_04_LinkedBlockingQueue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.queue.put(<span class="string">&quot;value&quot;</span> + t.r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                                    <span class="string">&quot; - &quot;</span> + t.queue.take());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;consumer&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-ArrayBlockingQueue"><a href="#3-3-ArrayBlockingQueue" class="headerlink" title="3.3 ArrayBlockingQueue"></a>3.3 ArrayBlockingQueue</h3><p>底层数组实现的有界队列。自动阻塞。根据调用 API(add&#x2F;put&#x2F;offer)不同，有不同特性。<br>当容量不足的时候，有阻塞能力。<br>add 方法：在容量不足的时候，抛出异常。put 方法在容量不足的时候，阻塞等待。<br>offer 方法：单参数 offer 方法，不阻塞。容量不足的时候，返回 false。当前新增数据操作放弃。 三参数 offer 方法(offer(value,times,timeunit))，容量不足的时候，阻塞 times 时长(单位为 timeunit)，如果在阻塞时长内，有容量空闲，新增数据返回 true。如果阻塞时长范围内，无容量空闲，放弃新增数据，返回 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - ArrayBlockingQueue</span></span><br><span class="line"><span class="comment"> * 有界容器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_05_ArrayBlockingQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test_05_ArrayBlockingQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_05_ArrayBlockingQueue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;add method : &quot; + t.queue.add(&quot;value&quot;+i));</span></span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                t.queue.put(&quot;put&quot;+i);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;put method : &quot; + i);*/</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;offer method : &quot; + t.queue.offer(&quot;value&quot;+i));</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;offer method : &quot;</span> +</span><br><span class="line">                        t.queue.offer(<span class="string">&quot;value&quot;</span> + i, <span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(t.queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-DelayQueue"><a href="#3-4-DelayQueue" class="headerlink" title="3.4 DelayQueue"></a>3.4 DelayQueue</h3><p>延时队列。根据比较机制，实现自定义处理顺序的队列。常用于定时任务。<br>如:定时关机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - DelayQueue</span></span><br><span class="line"><span class="comment"> * 无界容器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_06_DelayQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;MyTask_06&gt; queue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">MyTask_06</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">2000</span>);</span><br><span class="line">        <span class="type">MyTask_06</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">1000</span>);</span><br><span class="line">        <span class="type">MyTask_06</span> <span class="variable">task3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">3000</span>);</span><br><span class="line">        <span class="type">MyTask_06</span> <span class="variable">task4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">2500</span>);</span><br><span class="line">        <span class="type">MyTask_06</span> <span class="variable">task5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">        queue.put(task1);</span><br><span class="line">        queue.put(task2);</span><br><span class="line">        queue.put(task3);</span><br><span class="line">        queue.put(task4);</span><br><span class="line">        queue.put(task5);</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask_06</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> compareValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask_06</span><span class="params">(<span class="type">long</span> compareValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.compareValue = compareValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较大小。自动实现升序</span></span><br><span class="line"><span class="comment">     * 建议和getDelay方法配合完成。</span></span><br><span class="line"><span class="comment">     * 如果在DelayQueue是需要按时间完成的计划任务，必须配合getDelay方法完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取计划时长的方法。</span></span><br><span class="line"><span class="comment">     * 根据参数TimeUnit来决定，如何返回结果值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(compareValue - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Task compare value is : &quot;</span> + <span class="built_in">this</span>.compareValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-LinkedTransferQueue"><a href="#3-5-LinkedTransferQueue" class="headerlink" title="3.5 LinkedTransferQueue"></a>3.5 LinkedTransferQueue</h3><p>转移队列，是一个容量为 0 的队列。使用 transfer 方法，实现数据的即时处理。没有消费者，就阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - LinkedTransferQueue</span></span><br><span class="line"><span class="comment"> * 转移队列</span></span><br><span class="line"><span class="comment"> * add - 队列会保存数据，不做阻塞等待。</span></span><br><span class="line"><span class="comment"> * transfer - 是TransferQueue的特有方法。必须有消费者（take()方法的调用者）。</span></span><br><span class="line"><span class="comment"> * 如果没有任意线程消费数据，transfer方法阻塞。一般用于处理即时消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedTransferQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TransferQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_07_TransferQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    TransferQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedTransferQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test_07_TransferQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_07_TransferQueue</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName() + &quot; thread begin &quot; );</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName() + &quot; - &quot; + t.queue.take());</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;output thread&quot;).start();</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            t.queue.transfer(&quot;test string&quot;);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.queue.transfer(<span class="string">&quot;test string&quot;</span>);</span><br><span class="line">                    <span class="comment">// t.queue.add(&quot;test string&quot;);</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;add ok&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread begin &quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + t.queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;output thread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-SynchronusQueue"><a href="#3-6-SynchronusQueue" class="headerlink" title="3.6 SynchronusQueue"></a>3.6 SynchronusQueue</h3><p>同步队列，是一个容量为0的队列。是一个特殊的TransferQueue。必须现有消费线程等待，才能使用的队列。<br>add 方法，无阻塞。若没有消费线程阻塞等待数据，则抛出异常。<br>put 方法，有阻塞。若没有消费线程阻塞等待数据，则阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - SynchronousQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_08_SynchronusQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test_08_SynchronusQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_08_SynchronusQueue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread begin &quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + t.queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;output thread&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">            TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// t.queue.add(&quot;test add&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.queue.put(<span class="string">&quot;test put&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; queue size : &quot;</span> + t.queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java并发编程(二)：volatile关键字</title>
    <url>/2022/02/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%8C)%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用，一句话概括就是<strong>内存可见性</strong>和禁止重排序。<br>1）保证被volatile修饰的共享变量对所有线程总是可见的，也就是<strong>当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</strong><br>2）禁止指令重排序优化。在执行程序时为了提高性能，编译器和处理器通常会重新安排指令的执行顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="type">boolean</span> running=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m start&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running)&#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;m end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        T t=<span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;t.m(),<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.running=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中没加volatile的话，循环的后面的输出语句”m end”不会输出，但是main方法里面确实是已经将running的值改成了false。这里有关java的<strong>内存模型</strong>，简单来说就是程序运行时，running的值已经被加载到了缓存里面，而改的是t对象的running值在堆内存中。加了volatile就不一样了，它改完数值之后，会通知其他线程，让其他线程重新读一下堆内存中的值，也就是内存可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        T1 t=<span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">        List&lt;Thread&gt; threads=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;t.m(),<span class="string">&quot;thread-&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        threads.forEach((o)-&gt;o.start());</span><br><span class="line">        threads.forEach((o)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，十个线程执行count++加到1w循环，理想状态当然是加到10w，但是volatile只能保持线程的可见性，不能保持原子性。给count变量加上了volatile，最后输出的count值也达不到10w。这就是volatile与synchronized的区别，<strong>volatile只能保持可见性，而synchronized可以保持可见性和原子性。</strong>但是volatile更加轻量级，能用volatile的情况下，尽量别用synchronized。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux环境下部署node.js项目并使用pm2对项目进行管理</title>
    <url>/2023/12/21/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2node-js%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BD%BF%E7%94%A8pm2%E5%AF%B9%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>node.js是让JavaScript能运行在服务端的开发平台，pm2是一个Node.js 守护进程管理器，可以用于管理和监控Node.js 应用程序。</p>
</blockquote>
<h2 id="一、安装node环境"><a href="#一、安装node环境" class="headerlink" title="一、安装node环境"></a>一、安装node环境</h2><h3 id="1-可通过网站下载，进入Node最新版下载"><a href="#1-可通过网站下载，进入Node最新版下载" class="headerlink" title="1.可通过网站下载，进入Node最新版下载 &lt;https://nodejs.org/en/download/current/"></a>1.可通过网站下载，进入Node最新版下载 &lt;<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://nodejs.org/en/download/current/&source=article&objectId=1772306">https://nodejs.org/en/download/current/</a></h3><ul>
<li><p>通过wget指令下载：<code>wget https://nodejs.org/dist/v13.11.0/node-v13.11.0-linux-x64.tar.xz</code></p>
</li>
<li><p>解压：<code>tar -xvf node-v13.11.0-linux-x64.tar.xz</code></p>
</li>
<li><p>测试安装是否成功：<code>cd node-v13.11.0-linux-x64/bin</code>，执行：<code>./node -v</code></p>
</li>
</ul>
<h3 id="2-添加node和npm软链建立链接（PS-ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接）："><a href="#2-添加node和npm软链建立链接（PS-ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接）：" class="headerlink" title="2.添加node和npm软链建立链接（PS:ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接）："></a>2.添加node和npm软链建立链接（<strong>PS:ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接</strong>）：</h3><ul>
<li><code>ln -s /www/node-v13.11.0-linux-x64/bin/node /usr/local/bin/node</code></li>
<li><code>ln -s /www/node-v13.11.0-linux-x64/bin/npm /usr/local/bin/npm</code></li>
</ul>
<h3 id="2-1或者是通过改变node包的存放位置进行操作：mv-node-v13-11-0-linux-x64-usr-local-node"><a href="#2-1或者是通过改变node包的存放位置进行操作：mv-node-v13-11-0-linux-x64-usr-local-node" class="headerlink" title="2.1或者是通过改变node包的存放位置进行操作：mv node-v13.11.0-linux-x64 /usr/local/node"></a>2.1或者是通过改变node包的存放位置进行操作：<code>mv node-v13.11.0-linux-x64 /usr/local/node</code></h3><p>再编辑配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">按住i键，进入编辑模式</span><br><span class="line"></span><br><span class="line">插入：export PATH=$PATH:/usr/local/node/bin</span><br><span class="line"></span><br><span class="line">按esc,输入:wq，退出vim编辑器模式</span><br></pre></td></tr></table></figure>



<h3 id="3-使用测试命令：node-v和npm-v"><a href="#3-使用测试命令：node-v和npm-v" class="headerlink" title="3.使用测试命令：node -v和npm -v"></a>3.使用测试命令：<code>node -v</code>和<code>npm -v</code></h3><h3 id="4-加速npm"><a href="#4-加速npm" class="headerlink" title="4.加速npm"></a>4.加速npm</h3><ul>
<li>使用淘宝的cnpm：<code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></li>
<li>加cnpm软链：<code>ln -s /www/node-v13.11.0-linux-x64/bin/cnpm /usr/local/bin/cnpm</code></li>
<li>需要注意，以后使用cnpm去代替npm来执行，比如：<code>cnpm install XXX</code></li>
</ul>
<h2 id="二、安装并使用pm2"><a href="#二、安装并使用pm2" class="headerlink" title="二、安装并使用pm2"></a>二、安装并使用pm2</h2><blockquote>
<p>PM2 是一个流行的进程管理器，是在生产环境中后台运行 nodejs 的首选。它提供了很多的功能和选项，包括进程监控、自动重启、负载平衡等等。使用 PM2 后，我们可以方便地将 nodejs 应用程序后台运行。</p>
</blockquote>
<h3 id="1-安装pm2：npm-install-g-pm2"><a href="#1-安装pm2：npm-install-g-pm2" class="headerlink" title="1.安装pm2：npm install -g pm2"></a>1.安装pm2：<code>npm install -g pm2</code></h3><h3 id="2-添加pm2软链：ln-s-www-node-v13-11-0-linux-x64-lib-node-modules-pm2-bin-pm2-usr-local-bin"><a href="#2-添加pm2软链：ln-s-www-node-v13-11-0-linux-x64-lib-node-modules-pm2-bin-pm2-usr-local-bin" class="headerlink" title="2.添加pm2软链：ln -s /www/node-v13.11.0-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/local/bin/"></a>2.添加pm2软链：<code>ln -s /www/node-v13.11.0-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/local/bin/</code></h3><h3 id="3-pm2常用命令："><a href="#3-pm2常用命令：" class="headerlink" title="3.pm2常用命令："></a>3.pm2常用命令：</h3><ul>
<li><p>启动指定应用：<code>pm2 start &lt;script_file|config_file&gt; [options]</code> ，如：<code>pm2 start index.js --name httpServer</code></p>
</li>
<li><p>停止指定应用：<code>pm2 stop &lt;appName&gt; [options]</code>，如：<code>pm2 stop httpServer</code></p>
</li>
<li><p>查看全部实例：<code>pm2 list</code> ，注意：pm2 stop 某个项目后，该项目还会存在pm2 list 的列表里面， 只是状态是 stop, 要想去掉该项目，用pm2 delete</p>
</li>
<li><p>重启指定应用：<code>pm2 reload|restart &lt;appName&gt; [options]</code>，如：<code>pm2 restart httpServer</code></p>
</li>
<li><p>显示指定应用详情：<code>pm2 show &lt;appName&gt; [options]</code>，如：<code>pm2 show httpServer</code></p>
</li>
<li><p>删除指定应用：<code>pm2 delete &lt;appName&gt; [options]</code>，如：<code>pm2 delete httpServer</code>，如果修改应用配置行为，最好先删除应用后，重新启动方才生效，如修改脚本入口文件</p>
</li>
<li><p>杀掉pm2管理的所有进程<code>pm2 kill</code> </p>
</li>
<li><p>查看指定应用的日志，即标准输出和标准错误<code>pm2 logs &lt;appName&gt;</code></p>
</li>
<li><p>监控各个应用进程cpu和memory使用情况<code>pm2 monit</code></p>
</li>
<li><p>如果项目没有启动就执行 start 如果项目正在运行 就执行relaod<code>pm2 startOrReload &lt;appName&gt;</code></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Redis面试总结&amp;史上最全Redis面试题及答案(转)</title>
    <url>/2022/02/12/Redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&amp;%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88(%E8%BD%AC)/</url>
    <content><![CDATA[<p>Redis 在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在 Redis 的使用和原理方面对小伙伴们进行各种刁难。作为一名在互联网技术行业打击过成百上千名【请允许我夸张一下】的资深技术面试官，看过了无数落寞的身影失望的离开，略感愧疚，故献上此文，希望各位读者以后面试势如破竹，永无失败！</p>
<h3 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h3><p>字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。</p>
<p>如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub&#x2F;Sub。</p>
<p>如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p>
<h3 id="使用过-Redis-分布式锁么，它是什么回事？"><a href="#使用过-Redis-分布式锁么，它是什么回事？" class="headerlink" title="使用过 Redis 分布式锁么，它是什么回事？"></a>使用过 Redis 分布式锁么，它是什么回事？</h3><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<p>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</p>
<p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<p>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</p>
<p>使用 keys 指令可以扫出指定模式的 key 列表。</p>
<p>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</p>
<p>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p>
<h3 id="使用过-Redis-做异步队列么，你是怎么用的？"><a href="#使用过-Redis-做异步队列么，你是怎么用的？" class="headerlink" title="使用过 Redis 做异步队列么，你是怎么用的？"></a>使用过 Redis 做异步队列么，你是怎么用的？</h3><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<p>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<p>如果对方追问能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现 1:N 的消息队列。</p>
<p>如果对方追问 pub&#x2F;sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</p>
<p>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</p>
<p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<p>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</p>
<p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h3 id="Redis-如何做持久化的？"><a href="#Redis-如何做持久化的？" class="headerlink" title="Redis 如何做持久化的？"></a>Redis 如何做持久化的？</h3><p>bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 aof 来配合使用。在 redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 aof 重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p>对方追问那如果突然机器掉电会怎样？取决于 aof 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync，比如 1s1 次，这个时候最多就会丢失 1s 的数据。</p>
<p>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow。fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<h3 id="Pipeline-有什么好处，为什么要用-pipeline？"><a href="#Pipeline-有什么好处，为什么要用-pipeline？" class="headerlink" title="Pipeline 有什么好处，为什么要用 pipeline？"></a>Pipeline 有什么好处，为什么要用 pipeline？</h3><p>可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。</p>
<h3 id="Redis-的同步机制了解么？"><a href="#Redis-的同步机制了解么？" class="headerlink" title="Redis 的同步机制了解么？"></a>Redis 的同步机制了解么？</h3><p>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h3 id="是否使用过-Redis-集群，集群的原理是什么？"><a href="#是否使用过-Redis-集群，集群的原理是什么？" class="headerlink" title="是否使用过 Redis 集群，集群的原理是什么？"></a>是否使用过 Redis 集群，集群的原理是什么？</h3><p>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</p>
<p>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</p>
<h2 id="史上最全Redis面试题及答案"><a href="#史上最全Redis面试题及答案" class="headerlink" title="史上最全Redis面试题及答案"></a>史上最全Redis面试题及答案</h2><p>1、什么是Redis？</p>
<p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<p>2、Redis相比memcached有哪些优势？</p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<p>3、Redis支持哪几种数据类型？</p>
<p>String、List、Set、Sorted Set、hashes</p>
<p>4、Redis主要消耗什么物理资源？</p>
<p>内存。</p>
<p>5、Redis的全称是什么？</p>
<p>Remote Dictionary Server。</p>
<p>6、Redis有哪几种数据淘汰策略？</p>
<p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p>
<p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>
<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p>
<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p>
<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>
<p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
<p>7、Redis官方为什么不提供Windows版本？</p>
<p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<p>8、一个字符串类型的值能存储最大容量是多少？</p>
<p>512M</p>
<p>9、为什么Redis需要把所有数据放到内存中？</p>
<p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I&#x2F;O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<p>10、Redis集群方案应该怎么做？都有哪些方案？</p>
<p>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p>
<p>2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。</p>
<p>3.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>
<p>4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
<p>11、Redis集群方案什么情况下会导致整个集群不可用？</p>
<p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p>
<p>12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</p>
<p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<p>13、Redis有哪些适合的场景？</p>
<p>（1）、会话缓存（Session Cache）</p>
<p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p>
<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p>
<p>（2）、全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p>
<p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p>
<p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>（3）、队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push&#x2F;pop 操作。</p>
<p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p>
<p>（4），排行榜&#x2F;计数器</p>
<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p>
<p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p>
<p>ZRANGE user_scores 0 10 WITHSCORES</p>
<p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p>
<p>（5）、发布&#x2F;订阅</p>
<p>最后（但肯定不是最不重要的）是Redis的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用Redis的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p>
<p>14、Redis支持的Java客户端都有哪些？官方推荐用哪个？</p>
<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<p>15、Redis和Redisson有什么关系？</p>
<p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>
<p>16、Jedis与Redisson对比有什么优缺点？</p>
<p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p>17、Redis如何设置密码及验证密码？</p>
<p>设置密码：config set requirepass 123456</p>
<p>授权密码：auth 123456</p>
<p>18、说说Redis哈希槽的概念？</p>
<p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<p>19、Redis集群的主从复制模型是怎样的？</p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>20、Redis集群会有写操作丢失吗？为什么？</p>
<p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<p>21、Redis集群之间是如何复制的？</p>
<p>异步复制</p>
<p>22、Redis集群最大节点个数是多少？</p>
<p>16384个。</p>
<p>23、Redis集群如何选择数据库？</p>
<p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<p>24、怎么测试Redis的连通性？</p>
<p>ping</p>
<p>25、Redis中的管道有什么用？</p>
<p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>26、怎么理解Redis事务？</p>
<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>27、Redis事务相关的命令有哪几个？</p>
<p>MULTI、EXEC、DISCARD、WATCH</p>
<p>28、Redis key的过期时间和永久有效分别怎么设置？</p>
<p>EXPIRE和PERSIST命令。</p>
<p>29、Redis如何做内存优化？</p>
<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</p>
<p>30、Redis回收进程如何工作的？</p>
<p>一个客户端运行了新的命令，添加了新的数据。<br>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。<br>一个新的命令被执行，等等。<br>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。<br>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<p>31、Redis回收使用的是什么算法？</p>
<p>LRU算法</p>
<p>32、Redis如何做大量数据插入？</p>
<p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<p>33、为什么要做Redis分区？</p>
<p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<p>34、你知道有哪些Redis分区实现方案？</p>
<p>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</p>
<p>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</p>
<p>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</p>
<p>35、Redis分区有什么缺点？</p>
<p>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。<br>同时操作多个key,则不能使用Redis事务.<br>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.<br>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB &#x2F; AOF文件。<br>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。<br>36、Redis持久化数据和缓存怎么做扩容？</p>
<p>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。<br>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。<br>37、分布式Redis是前期做还是后期规模上来了再做好？为什么？</p>
<p>既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<p>38、Twemproxy是什么？</p>
<p>Twemproxy是Twitter维护的（缓存）代理系统，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。 Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。 Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。 Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>
<p>39、支持一致性哈希的客户端有哪些？</p>
<p>Redis-rb、Predis等。</p>
<p>40、Redis与其他key-value存储有什么不同？</p>
<p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。<br>41、Redis的内存占用情况怎么样？</p>
<p>给你举个例子： 100万个键值对（键是0到999999值是字符串“hello world”）在我的32位的Mac笔记本上 用了100MB。同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。</p>
<p>当然，大键值对时两者的比例要好很多。</p>
<p>64位的系统比32位的需要更多的内存开销，尤其是键值对都较小时，这是因为64位的系统里指针占用了8个字节。 但是，当然，64位系统支持更大的内存，所以为了运行大型的Redis服务器或多或少的需要使用64位的系统。</p>
<p>42、都有哪些办法可以降低Redis的内存使用情况呢？</p>
<p>如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。</p>
<p>43、查看Redis使用情况及状态信息用什么命令？</p>
<p>info</p>
<p>44、Redis的内存用完了会发生什么？</p>
<p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<p>45、Redis是单线程的，如何提高多核CPU的利用率？</p>
<p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<p>46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</p>
<p>理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。</p>
<p>任何list、set、和sorted set都可以放232个元素。</p>
<p>换句话说，Redis的存储极限是系统中的可用内存值。</p>
<p>47、Redis常见性能问题和解决方案？</p>
<p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p>
<p>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p>
<p>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p>
<p>(4) 尽量避免在压力很大的主库上增加从库</p>
<p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p>
<p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p>
<p>48、Redis提供了哪几种持久化方式？</p>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.<br>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.<br>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.<br>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.<br>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。<br>49、如何选择合适的持久化方式？</p>
<p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p>
<p>有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的bug。</p>
<p>50、修改配置不重启Redis会实时生效吗？</p>
<p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。</p>
<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
<p>转载于：<a href="https://cloudpai.gitee.io/2018/04/18/2018-04-18-3/">https://cloudpai.gitee.io/2018/04/18/2018-04-18-3/</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot实现图片上传demo以及Nginx进行代理显示</title>
    <url>/2022/02/12/SpringBoot%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0demo%E4%BB%A5%E5%8F%8ANginx%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>公司项目需要一个图片上传的功能，就图片能上传到服务器（公司用的windows服务器），然后nginx能进行代理访问到就行了，先简单介绍一下nginx，然后再来实现功能。</p>
<h1 id="一、nginx简介"><a href="#一、nginx简介" class="headerlink" title="一、nginx简介"></a>一、nginx简介</h1><blockquote>
<p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。<br>Nginx专门为性能优化而开发，性能是其最重要的考量，实际上非常注重效率，能经起高负载的考验，有报告表明能支持高达50000个并发连接数。</p>
</blockquote>
<h1 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a>二、反向代理</h1><p>1.正向代理<br>在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问。<br>2.反向代理<br>我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<h1 id="三、负载均衡"><a href="#三、负载均衡" class="headerlink" title="三、负载均衡"></a>三、负载均衡</h1><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。</p>
<h1 id="四、动静分离"><a href="#四、动静分离" class="headerlink" title="四、动静分离"></a>四、动静分离</h1><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。减低原来单个服务器的压力。</p>
<h1 id="五、nginx常用命令"><a href="#五、nginx常用命令" class="headerlink" title="五、nginx常用命令"></a>五、nginx常用命令</h1><p>1.使用nginx操作命令前提条件：必须进行nginx的目录</p>
<p>2.查看nginx的版本号<br>nginx -v</p>
<p>3.启动nginx<br>nginx</p>
<p>4.关闭nginx<br>nginx -s stop</p>
<p>5.重新加载nginx<br>nginx -s reload</p>
<h1 id="六、nginx的配置文件（nginx-conf）"><a href="#六、nginx的配置文件（nginx-conf）" class="headerlink" title="六、nginx的配置文件（nginx.conf）"></a>六、nginx的配置文件（nginx.conf）</h1><p>nginx配置文件有三部分组成<br>1.全局块<br>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令。<br>比如：worker_processes 1; worker_processes值越大，可以支持的并发处理量也越多。</p>
<p>2.events块</p>
<p>events块涉及的指令主要影响nginx服务器与用户的网络连接。<br>比如：worker_connection 1024; 支持的最大连接数。</p>
<p>3.http块<br>nginx服务器配置中最频繁的部分，http块也可以包括http全局块、server块。</p>
<h1 id="七、nginx配置图片的访问路径"><a href="#七、nginx配置图片的访问路径" class="headerlink" title="七、nginx配置图片的访问路径"></a>七、nginx配置图片的访问路径</h1><p>图片文件上传至服务器D:&#x2F;images中，然后通过IP地址&#x2F;upload&#x2F;加图片名称进行访问。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #访问路径拼接 upload 访问本地绝对路径下的某图片 </span><br><span class="line">        location /upload/ &#123;</span><br><span class="line">        alias D:/images/;</span><br><span class="line">        autoindex on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好nginx.conf记得重启一下服务器。效果如图：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/83f770e8dad9c1ca09033b2e9ce6037f.png" alt="image.png"></p>
<h1 id="八、java后台代码"><a href="#八、java后台代码" class="headerlink" title="八、java后台代码"></a>八、java后台代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/fileUpload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fileUpload</span><span class="params">(<span class="meta">@RequestParam(value = &quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请选择图片&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();  <span class="comment">// 文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));  <span class="comment">// 后缀名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/images/&quot;</span>; <span class="comment">// 上传后的路径</span></span><br><span class="line">        fileName = UUID.randomUUID() + suffixName; <span class="comment">// 新文件名</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath + fileName);</span><br><span class="line">        <span class="keyword">if</span> (!dest.getParentFile().exists()) &#123;</span><br><span class="line">            dest.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(dest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回图片名称</span></span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将图片上传至D:&#x2F;images文件夹中，因为前面配置了nginx的缘故，我这里是在本地测试的，直接使用localhost&#x2F;upload&#x2F;+返回的图片名称就可以访问到了。</p>
<p>如果想要通过项目的地址外加端口号进行访问的话，可以配置一个资源映射路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源映射路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/upload/**&quot;</span>).addResourceLocations(<span class="string">&quot;file:D:/images/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>like this!<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/ef6fa062cb4f717a5d1287f49357592f.png" alt="image.png"></p>
<p>项目代码可在<a href="github">github</a>进行查看</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot+Vue前后端分离项目部署教程(转)</title>
    <url>/2022/06/01/SpringBoot-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B(%E8%BD%AC)/</url>
    <content><![CDATA[<h2 id="1-打包后端项目jar包"><a href="#1-打包后端项目jar包" class="headerlink" title="1.打包后端项目jar包"></a>1.打包后端项目jar包</h2><p>打开pom.xml文件，修改packaging方式为jar<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/1b2cb327efd7ff924aed08f1b823c4a4.png" alt="image.png"></p>
<p>点击右侧maven插件 -&gt; package<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/13824b79027f796b472c606e9fd34358.png" alt="image.png"></p>
<p>打包成功后会在target目录下生成jar包<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/56a039e0a216ddb1119aea33946b87e0.png" alt="image.png"></p>
<h2 id="2-编写Dockerfile文件"><a href="#2-编写Dockerfile文件" class="headerlink" title="2.编写Dockerfile文件"></a>2.编写Dockerfile文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD blog-springboot-0.0.1.jar blog.jar       </span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/blog.jar&quot;</span>] </span><br><span class="line">sh</span><br><span class="line">FROM java:8</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD blog-springboot-0.0.1.jar blog.jar       </span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/blog.jar&quot;</span>] </span><br></pre></td></tr></table></figure>
<p>ps：Dockerfile文件不需要后缀，直接为文件格式</p>
<h2 id="3-编写blog-start-sh脚本"><a href="#3-编写blog-start-sh脚本" class="headerlink" title="3.编写blog-start.sh脚本"></a>3.编写blog-start.sh脚本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#源jar路径  </span></span><br><span class="line">SOURCE_PATH=/usr/local/docker</span><br><span class="line"><span class="comment">#docker 镜像/容器名字或者jar名字 这里都命名为这个</span></span><br><span class="line">SERVER_NAME=blog-springboot-0.0.1.jar</span><br><span class="line">TAG=latest</span><br><span class="line">SERVER_PORT=8080</span><br><span class="line"><span class="comment">#容器id</span></span><br><span class="line">CID=$(docker ps | grep <span class="string">&quot;<span class="variable">$SERVER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#镜像id</span></span><br><span class="line">IID=$(docker images | grep <span class="string">&quot;<span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;存在容器<span class="variable">$SERVER_NAME</span>, CID-<span class="variable">$CID</span>&quot;</span></span><br><span class="line">  docker stop <span class="variable">$SERVER_NAME</span></span><br><span class="line">  docker <span class="built_in">rm</span> <span class="variable">$SERVER_NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 构建docker镜像</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;存在<span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span>镜像，IID=<span class="variable">$IID</span>&quot;</span></span><br><span class="line">  docker rmi <span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;不存在<span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span>镜像，开始构建镜像&quot;</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$SOURCE_PATH</span></span><br><span class="line">  docker build -t <span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span> .</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 运行docker容器</span></span><br><span class="line">docker run --name <span class="variable">$SERVER_NAME</span> -v /usr/local/upload:/usr/local/upload -d -p <span class="variable">$SERVER_PORT</span>:<span class="variable">$SERVER_PORT</span> <span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span>容器创建完成&quot;</span></span><br><span class="line">sh</span><br><span class="line"><span class="comment">#源jar路径  </span></span><br><span class="line">SOURCE_PATH=/usr/local/docker</span><br><span class="line"><span class="comment">#docker 镜像/容器名字或者jar名字 这里都命名为这个</span></span><br><span class="line">SERVER_NAME=blog-springboot-0.0.1.jar</span><br><span class="line">TAG=latest</span><br><span class="line">SERVER_PORT=8080</span><br><span class="line"><span class="comment">#容器id</span></span><br><span class="line">CID=$(docker ps | grep <span class="string">&quot;<span class="variable">$SERVER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#镜像id</span></span><br><span class="line">IID=$(docker images | grep <span class="string">&quot;<span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;存在容器<span class="variable">$SERVER_NAME</span>, CID-<span class="variable">$CID</span>&quot;</span></span><br><span class="line">  docker stop <span class="variable">$SERVER_NAME</span></span><br><span class="line">  docker <span class="built_in">rm</span> <span class="variable">$SERVER_NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 构建docker镜像</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;存在<span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span>镜像，IID=<span class="variable">$IID</span>&quot;</span></span><br><span class="line">  docker rmi <span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;不存在<span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span>镜像，开始构建镜像&quot;</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$SOURCE_PATH</span></span><br><span class="line">  docker build -t <span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span> .</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 运行docker容器</span></span><br><span class="line">docker run --name <span class="variable">$SERVER_NAME</span> -v /usr/local/upload:/usr/local/upload -d -p <span class="variable">$SERVER_PORT</span>:<span class="variable">$SERVER_PORT</span> <span class="variable">$SERVER_NAME</span>:<span class="variable">$TAG</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span>容器创建完成&quot;</span></span><br></pre></td></tr></table></figure>
<p>ps：sh文件需要用notepad++转为Unix格式<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/aaed807d8df80aae11a94ea00df2264c.png" alt="image.png"></p>
<h2 id="4-将文件传输到服务器"><a href="#4-将文件传输到服务器" class="headerlink" title="4.将文件传输到服务器"></a>4.将文件传输到服务器</h2><p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/183030180db2eb36f8949a2c81cb02ea.png" alt="image.png"></p>
<p>将上述三个文件传输到&#x2F;usr&#x2F;local&#x2F;docker下（手动创建文件夹）<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/d84ab03c0e7b56ee01dce5f89d30d554.png" alt="image.png"></p>
<h2 id="5-docker运行后端项目"><a href="#5-docker运行后端项目" class="headerlink" title="5.docker运行后端项目"></a>5.docker运行后端项目</h2><p>进入服务器&#x2F;usr&#x2F;local&#x2F;docker下，构建后端镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh ./blog-start.sh </span><br></pre></td></tr></table></figure>

<p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/9a59bf2c7c8c465b707e5645a4b175b1.png" alt="image.png"><br>ps：第一次时间可能比较长，耐心等待即可</p>
<p>查看是否构建成功<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/1096233de4147cd81b65728a495914a7.png" alt="image.png"></p>
<p>可以去测试下接口是否运行成功<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/a91b807200f73c0c406eae9ffb1e4297.png" alt="image.png"><br>ps：需要重新部署只需重新传jar包，执行sh脚本即可</p>
<h2 id="6-打包前端项目"><a href="#6-打包前端项目" class="headerlink" title="6.打包前端项目"></a>6.打包前端项目</h2><p>打开cmd，进入Vue项目路径 -&gt; npm run build<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/718358e5cc8e32b6ed1b0e0788dd7e22.png" alt="image.png"></p>
<p>打包成功后会在目录下生成dist文件<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/0b0b7a9a815eeef02e658c15ea0b564b.png" alt="image.png"></p>
<p>将Vue打包项目传输到&#x2F;usr&#x2F;local&#x2F;vue下（由于我前台和后台分为两个项目，所以改名dist文件）<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/d8eb85b7f7bd34b93b1d2ac9b24142fb.png" alt="image.png"></p>
<h2 id="7-nginx配置-有域名选这个"><a href="#7-nginx配置-有域名选这个" class="headerlink" title="7.nginx配置(有域名选这个)"></a>7.nginx配置(有域名选这个)</h2><p>在&#x2F;usr&#x2F;local&#x2F;nginx下创建nginx.conf文件，格式如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    client_max_body_size     50m;</span><br><span class="line">    client_body_buffer_size  10m; </span><br><span class="line">    client_header_timeout    1m;</span><br><span class="line">    client_body_timeout      1m;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length  1k;</span><br><span class="line">    gzip_buffers     4 16k;</span><br><span class="line">    gzip_comp_level  4;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  前台域名;</span><br><span class="line">     </span><br><span class="line">        location / &#123;		</span><br><span class="line">            root   /usr/local/vue/blog;</span><br><span class="line">            index  index.html index.htm; </span><br><span class="line">            try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;	</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">	location ^~ /api/ &#123;		</span><br><span class="line">            proxy_pass http://你的ip:8080/;</span><br><span class="line">	    proxy_set_header   Host             <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>;						</span><br><span class="line">            proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  后台子域名;</span><br><span class="line">     </span><br><span class="line">        location / &#123;		</span><br><span class="line">            root   /usr/local/vue/admin;</span><br><span class="line">            index  index.html index.htm; </span><br><span class="line">            try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;	</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">	location ^~ /api/ &#123;		</span><br><span class="line">            proxy_pass http://你的ip:8080/;</span><br><span class="line">	    proxy_set_header   Host             <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>;						</span><br><span class="line">            proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  websocket子域名;</span><br><span class="line">     </span><br><span class="line">        location / &#123;</span><br><span class="line">          proxy_pass http://你的ip:8080/websocket;</span><br><span class="line">          proxy_http_version 1.1;</span><br><span class="line">          proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">          proxy_set_header Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">          proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">          proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">          proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">          proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  上传文件子域名;</span><br><span class="line">     </span><br><span class="line">        location / &#123;		</span><br><span class="line">          <span class="built_in">alias</span> /usr/local/upload/; </span><br><span class="line">          autoindex on;</span><br><span class="line">          autoindex_exact_size on;</span><br><span class="line">          autoindex_localtime on;</span><br><span class="line">        &#125;		</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>ps：我前台和后台时分为两个域名，所以写了两个server，前端项目路径为之前传输的路径，其他两个为文件上传域名和websocket转发域名。</p>
<p>docker启动nginx服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name nginx --restart=always -p 80:80 -d -v /usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/vue:/usr/local/vue -v /usr/local/upload:/usr/local/upload nginx </span><br></pre></td></tr></table></figure>

<h2 id="8-nginx配置-无域名选这个"><a href="#8-nginx配置-无域名选这个" class="headerlink" title="8.nginx配置(无域名选这个)"></a>8.nginx配置(无域名选这个)</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    client_max_body_size     50m;</span><br><span class="line">    client_body_buffer_size  10m; </span><br><span class="line">    client_header_timeout    1m;</span><br><span class="line">    client_body_timeout      1m;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length  1k;</span><br><span class="line">    gzip_buffers     4 16k;</span><br><span class="line">    gzip_comp_level  4;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  你的ip;</span><br><span class="line">     </span><br><span class="line">        location / &#123;		</span><br><span class="line">            root   /usr/local/vue/blog;</span><br><span class="line">            index  index.html index.htm; </span><br><span class="line">            try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;	</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">	location ^~ /api/ &#123;		</span><br><span class="line">            proxy_pass http://你的ip:8080/;</span><br><span class="line">	    proxy_set_header   Host             <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>;						</span><br><span class="line">            proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">server &#123;</span><br><span class="line">        listen       81;</span><br><span class="line">        server_name  你的ip;</span><br><span class="line">     </span><br><span class="line">        location / &#123;		</span><br><span class="line">            root   /usr/local/vue/admin;</span><br><span class="line">            index  index.html index.htm; </span><br><span class="line">            try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;	</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">	location ^~ /api/ &#123;		</span><br><span class="line">            proxy_pass http://你的ip:8080/;</span><br><span class="line">	    proxy_set_header   Host             <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>;						</span><br><span class="line">            proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       82;</span><br><span class="line">        server_name  你的ip;</span><br><span class="line">     </span><br><span class="line">        location / &#123;</span><br><span class="line">          proxy_pass http://你的ip:8080/websocket;</span><br><span class="line">          proxy_http_version 1.1;</span><br><span class="line">          proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">          proxy_set_header Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">          proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">          proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">          proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">          proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       83;</span><br><span class="line">        server_name  你的ip;</span><br><span class="line">     </span><br><span class="line">        location / &#123;		</span><br><span class="line">          <span class="built_in">alias</span> /usr/local/upload/; </span><br><span class="line">          autoindex on;</span><br><span class="line">          autoindex_exact_size on;</span><br><span class="line">          autoindex_localtime on;</span><br><span class="line">        &#125;		</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>docker启动nginx服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name nginx --restart=always -p 80:80 -p 81:81 -p 82:82 -p 83:83 -d -v /usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/vue:/usr/local/vue -v /usr/local/upload:/usr/local/upload nginx </span><br></pre></td></tr></table></figure>
<p>ps：需要通过ip + 端口号访问项目</p>
<h2 id="9-运行测试"><a href="#9-运行测试" class="headerlink" title="9.运行测试"></a>9.运行测试</h2><p>去浏览器测试下是否运行成功<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/66732d08619276eea4be2f8ab7f32551.png" alt="image.png"></p>
<h2 id="10-其他设置"><a href="#10-其他设置" class="headerlink" title="10.其他设置"></a>10.其他设置</h2><p>进入后台管理 -&gt; 网站管理 -&gt; 其他设置，配置websocket域名<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/a97b2594f13b2928072728067ac68968.png" alt="image.png"></p>
<h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h2><p>整个前后端分离的部署教程到这里就结束啦，第一次部署可能会比较麻烦，不过后面就轻车熟路了，有问题的可以私聊问我或者在评论区留言。</p>
]]></content>
  </entry>
  <entry>
    <title>Shiro整合Redis:使用shiro-redis插件踩的坑</title>
    <url>/2022/06/01/Shiro%E6%95%B4%E5%90%88Redis-%E4%BD%BF%E7%94%A8shiro-redis%E6%8F%92%E4%BB%B6%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>　　一直想在shiro权限这块加入缓存，使用redis是再合适不过了，恰巧已经有大佬将shiro和redis整合在一起使用了，只需在引入pom文件中引入即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.crazycake<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是是使用的时候，权限配置这块，也就是重写shiro的doGetAuthorizationInfo方法这里，一直进不来，完整的控制台异常信息如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">org.crazycake.shiro.exception.PrincipalInstanceException: class com.company.project.manage.entity.UserInfo must has getter for field: id</span><br><span class="line">We need a field to identify this Cache Object in Redis. So you need to defined an id field which you can get unique id to identify this principal. For example, if you use UserInfo as Principal class, the id field maybe userId, userName, email, etc. For example, getUserId(), getUserName(), getEmail(), etc.</span><br><span class="line">Default value is &quot;id&quot;, that means your principal object has a method called &quot;getId()&quot;</span><br></pre></td></tr></table></figure>
<p>大概意思就是UserInfo对象中必须要有id属性，并且要有对应的get方法。在身份验证的时候就已经将userinfo信息传递给了shiro，然后redis做缓存的时候需要key，key的值就与userinfo里面的id值有关。<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/5d634f7823c441ee80b9356c5024cce4.png" alt="image.png"><br>点开UserInfo对象一看，尴了个尬，主键的命名使用的是uid<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/256e8900fd2c9cc5dfbb6629910f5775.png" alt="image.png"><br>最后把主键换成id，就运行正常了。</p>
<p>演示项目在我的github上面，shiro-redis插件的整合可以查看：<br><a href="https://mrbird.cc/Spring-Boot-Shiro%20cache.html">https://mrbird.cc/Spring-Boot-Shiro%20cache.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot使用Jwt处理跨域认证问题</title>
    <url>/2022/02/14/SpringBoot%E4%BD%BF%E7%94%A8Jwt%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>　　在前后端开发时为什么需要用户认证呢？原因是由于HTTP协定是不存储状态的，这意味着当我们透过账号密码验证一个使用者时，当下一个request请求时他就把刚刚的资料忘记了。于是我们的程序就不知道谁是谁了。 所以为了保证系统的安全，就需要验证用户是否处于登陆状态。</p>
<h1 id="一、JWT的组成"><a href="#一、JWT的组成" class="headerlink" title="一、JWT的组成"></a>一、JWT的组成</h1><p>JWT由Header、Payload、Signature三部分组成，分别用.分隔。</p>
<p>下面就是一个jwt真实的样子，说白了就是一个字符串，但是里面却存储了很重要的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJyYXljaGVuIiwiaWQiOjIsIm5hbWUiOiJyYXkiLCJwYXNzd29yZCI6IjMyMSIsImlhdCI6MTU5MDI5OTU0OCwiZXhwIjoxNTkwMzg1OTQ4fQ.ORJNldDIfffg7D3_xu0_dBWb16y4fPLtw_r6qgScFpQ</span><br></pre></td></tr></table></figure>
<p>Header：</p>
<blockquote>
<p>第一部分是请求头由两部分组成，alg与typ,第一个指定的是算法，第二指定的是类型。</p>
</blockquote>
<p>Payload</p>
<blockquote>
<p>第二部分是主体信息组成,用来存储JWT基本信息，或者是我们的信息。</p>
</blockquote>
<p>Signature</p>
<blockquote>
<p>第三部分主要是给第一部分跟第二部进行签名使用的,用来验证是否是我们服务器发起的Token，secret是我们的密钥。</p>
</blockquote>
<h1 id="二、在springboot项目中使用jwt做验证"><a href="#二、在springboot项目中使用jwt做验证" class="headerlink" title="二、在springboot项目中使用jwt做验证"></a>二、在springboot项目中使用jwt做验证</h1><p>具体流程：</p>
<ul>
<li>把用户的用户名和密码发到后端</li>
<li>后端进行校验，校验成功会生成token, 把token发送给客户端</li>
<li>客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。</li>
</ul>
<p>1.先引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.使用工具类生成token和验证token（生成token方法中存入了用户的信息）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发行者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUBJECT=<span class="string">&quot;raychen&quot;</span>;</span><br><span class="line">    <span class="comment">//过期时间 一天</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> EXPIRE=<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">    <span class="comment">//密钥</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPSECRET=<span class="string">&quot;raychen11&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">geneJsonWebToken</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span> || user.getId()==<span class="literal">null</span> || user.getName()==<span class="literal">null</span> || user.getPassword()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token=Jwts.builder().setSubject(SUBJECT)</span><br><span class="line">                .claim(<span class="string">&quot;id&quot;</span>,user.getId())</span><br><span class="line">                .claim(<span class="string">&quot;name&quot;</span>,user.getName())</span><br><span class="line">                .claim(<span class="string">&quot;password&quot;</span>,user.getPassword())</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+EXPIRE))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,APPSECRET).compact();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">checkJWT</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="comment">//仿造的token或者已过期就会报错</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims=Jwts.parser().setSigningKey(APPSECRET).parseClaimsJws(token).getBody();</span><br><span class="line">            <span class="keyword">return</span> claims;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.自定义注解（进行token验证）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckToken &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.编写config，将后台所有请求先去拦截器（拦截器返回了true，用户才可以请求到接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(authenticationInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);    <span class="comment">// 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationInterceptor <span class="title function_">authenticationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthenticationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.定义拦截器（对需要token验证的请求，进行验证，验证成功返回true，失败返回false无法请求到接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Gson gson=<span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入controller之前进行拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object object)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果不是映射到方法直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) object;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">//检查是否有LoginToken注释，有则跳过认证</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(LoginToken.class)) &#123;</span><br><span class="line">            <span class="type">LoginToken</span> <span class="variable">loginToken</span> <span class="operator">=</span> method.getAnnotation(LoginToken.class);</span><br><span class="line">            <span class="keyword">if</span> (loginToken.required()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前面是不需要token验证的 从 http 请求头中取出 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//检查有没有需要用户权限的注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(CheckToken.class)) &#123;</span><br><span class="line">            <span class="type">CheckToken</span> <span class="variable">checkToken</span> <span class="operator">=</span> method.getAnnotation(CheckToken.class);</span><br><span class="line">            <span class="keyword">if</span> (checkToken.required()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(token!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    Claims claims= JwtUtils.checkJWT(token);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="literal">null</span>==claims)&#123;</span><br><span class="line">                        sendJsonMessage(response, JsonData.buildError(<span class="string">&quot;token有误&quot;</span>));</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Integer userId= (Integer) claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    request.setAttribute(<span class="string">&quot;userId&quot;</span>,userId);</span><br><span class="line">                    request.setAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//token为null的话 返回一段json给前端</span></span><br><span class="line">                sendJsonMessage(response, JsonData.buildError(<span class="string">&quot;请登录&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有使用注解的方法 直接返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 响应数据给前端</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendJsonMessage</span> <span class="params">(HttpServletResponse response, Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            writer.print(gson.toJson(obj));</span><br><span class="line">            writer.close();</span><br><span class="line">            response.flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户登录成功后，使用工具类生成token。token在服务端不做存储，直接将token返回给客户端，客户端下次请求服务端时，使用工具类来验证header里的token是否合法。</p>
<p>项目代码地址：<a href="https://github.com/ruiyeclub/SpringBoot-Hello">https://github.com/ruiyeclub/SpringBoot-Hello</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Hibernate Validator实现参数验证功能</title>
    <url>/2022/06/01/SpringBoot%E6%95%B4%E5%90%88Hibernate-Validator%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>　　在前后端分离的开发模式中，后端对前端传入的参数的校验成了必不可少的一个环节。但是在多参数的情况下，在controller层加上参数验证，会显得特别臃肿，并且会有许多的重复代码。这里可以引用Hibernate Validator来解决这个问题，直接在实体类进行参数校验，验证失败直接返回错误信息给前端，减少controller层的代码量。</p>
<h1 id="一、pom引入Hibernate-Validator"><a href="#一、pom引入Hibernate-Validator" class="headerlink" title="一、pom引入Hibernate Validator"></a>一、pom引入Hibernate Validator</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 验证器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="二、通过注解在实体类进行参数校验"><a href="#二、通过注解在实体类进行参数校验" class="headerlink" title="二、通过注解在实体类进行参数校验"></a>二、通过注解在实体类进行参数校验</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名称不能为空！&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;age不能为null!&quot;)</span></span><br><span class="line">    <span class="meta">@Range(min = 1, max = 888, message = &quot;范围为1至888&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日期格式化转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;日期不能为null!&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到的参数校验的注解有@NotNull和@Range，message是到时候我们返回给前端的信息，注解的具体意思如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Null</span>  被注释的元素必须为<span class="literal">null</span></span><br><span class="line"><span class="meta">@NotNull</span>  被注释的元素不能为<span class="literal">null</span></span><br><span class="line"><span class="meta">@AssertTrue</span>  被注释的元素必须为<span class="literal">true</span></span><br><span class="line"><span class="meta">@AssertFalse</span>  被注释的元素必须为<span class="literal">false</span></span><br><span class="line"><span class="meta">@Min(value)</span>  被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"><span class="meta">@Max(value)</span>  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line"><span class="meta">@DecimalMin(value)</span>  被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"><span class="meta">@DecimalMax(value)</span>  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line"><span class="meta">@Size(max,min)</span>  被注释的元素的大小必须在指定的范围内。</span><br><span class="line"><span class="meta">@Digits(integer,fraction)</span>  被注释的元素必须是一个数字，其值必须在可接受的范围内</span><br><span class="line"><span class="meta">@Past</span>  被注释的元素必须是一个过去的日期</span><br><span class="line"><span class="meta">@Future</span>  被注释的元素必须是一个将来的日期</span><br><span class="line"><span class="meta">@Pattern(value)</span> 被注释的元素必须符合指定的正则表达式。</span><br><span class="line"><span class="meta">@Email</span> 被注释的元素必须是电子邮件地址</span><br><span class="line"><span class="meta">@Length</span> 被注释的字符串的大小必须在指定的范围内</span><br><span class="line"><span class="meta">@NotEmpty</span>  被注释的字符串必须非空</span><br><span class="line"><span class="meta">@Range</span>  被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure>
<h1 id="三、controller层的方法加上-Valid注解"><a href="#三、controller层的方法加上-Valid注解" class="headerlink" title="三、controller层的方法加上@Valid注解"></a>三、controller层的方法加上@Valid注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/testPost&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">testPost</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserModel userModel, BindingResult result)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">        <span class="keyword">for</span>(ObjectError error:result.getAllErrors())&#123;</span><br><span class="line">            <span class="keyword">return</span> error.getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller层这里只需要在实体类的前面加上@Valid注解，这个注解可以实现数据的验证。这里BindingResult是存储了校验时的错误信息，验证有误时将错误信息返回给前端。这里不使用BindingResult的时候，控制台会报MethodArgumentNotValidException，这里可以通过自定义异常类来捕捉它，然后去掉BindingResult，以及难看的if判断。</p>
<h1 id="四、自定义异常类捕捉MethodArgumentNotValidException"><a href="#四、自定义异常类捕捉MethodArgumentNotValidException" class="headerlink" title="四、自定义异常类捕捉MethodArgumentNotValidException"></a>四、自定义异常类捕捉MethodArgumentNotValidException</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> JsonData <span class="title function_">validException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        <span class="comment">//验证post请求的参数合法性</span></span><br><span class="line">        <span class="type">MethodArgumentNotValidException</span> <span class="variable">notValidException</span> <span class="operator">=</span> e;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> notValidException.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> JsonData.buildError(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用PostMan的测试结果如下：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/0e7da5f5ea00deaf1e69196d09085f49.png" alt="image.png"></p>
<p>具体的代码可以在我的github上面查看，<a href="https://github.com/ruiyeclub/SpringBoot-Hello">https://github.com/ruiyeclub/SpringBoot-Hello</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Mail发送邮件&amp;发送模板邮件</title>
    <url>/2022/06/01/SpringBoot%E6%95%B4%E5%90%88Mail%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6-%E5%8F%91%E9%80%81%E6%A8%A1%E6%9D%BF%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>　　整合mail发送邮件，其实就是通过代码来操作发送邮件的步骤，编辑收件人、邮件内容、邮件附件等等。通过邮件可以拓展出短信验证码、消息通知等业务。</p>
<h1 id="一、pom文件引入依赖"><a href="#一、pom文件引入依赖" class="headerlink" title="一、pom文件引入依赖"></a>一、pom文件引入依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--freemarker模板引擎是为了后面发送模板邮件 不需要的可以不引入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="二、application-yml文件中配置"><a href="#二、application-yml文件中配置" class="headerlink" title="二、application.yml文件中配置"></a>二、application.yml文件中配置</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    host: smtp.qq.xyz #这里换成自己的邮箱类型 例如qq邮箱就写smtp.qq.com</span><br><span class="line">    username: xx@qq.com #QQ邮箱</span><br><span class="line">    password: xxxxxxxxxxx #邮箱密码或者授权码</span><br><span class="line">    protocol: smtp #发送邮件协议</span><br><span class="line">    properties.mail.smtp.auth: true</span><br><span class="line">    properties.mail.smtp.port: 465 #端口号465或587</span><br><span class="line">    properties.mail.smtp.starttls.enable: true</span><br><span class="line">    properties.mail.smtp.starttls.required: true</span><br><span class="line">    properties.mail.smtp.ssl.enable: true #开启SSL</span><br><span class="line">    default-encoding: utf-8</span><br><span class="line">freemarker:</span><br><span class="line">  cache: false # 缓存配置 开发阶段应该配置为false 因为经常会改</span><br><span class="line">  suffix: .html # 模版后缀名 默认为ftl</span><br><span class="line">  charset: UTF-8 # 文件编码</span><br><span class="line">  template-loader-path: classpath:/templates/  # 存放模板的文件夹，以resource文件夹为相对路径</span><br></pre></td></tr></table></figure>
<p>邮箱密码暴露在配置文件很不安全，一般都是采取授权码的形式。点开邮箱，然后在账户栏里面点击生成授权码：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/c2d0d1f35a98ed2c68a4fdc2e120dbc6.png" alt="image.png"></p>
<h1 id="三、编写MailUtils工具类"><a href="#三、编写MailUtils工具类" class="headerlink" title="三、编写MailUtils工具类"></a>三、编写MailUtils工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring官方提供的集成邮件服务的实现类，目前是Java后端发送邮件和集成邮件服务的主流工具。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件中注入发件人的姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FreeMarkerConfigurer freeMarkerConfigurer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文本邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to      收件人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 正文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        <span class="comment">//发件人</span></span><br><span class="line">        message.setFrom(fromEmail);</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        mailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送html邮件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendHtmlMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意这里使用的是MimeMessage</span></span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            <span class="comment">//第二个参数：格式是否为html</span></span><br><span class="line">            helper.setText(content, <span class="literal">true</span>);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MessagingException e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;发送邮件时发生异常！&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送模板邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> template</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTemplateMail</span><span class="params">(String to, String subject, String template)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得模板</span></span><br><span class="line">            <span class="type">Template</span> <span class="variable">template1</span> <span class="operator">=</span> freeMarkerConfigurer.getConfiguration().getTemplate(template);</span><br><span class="line">            <span class="comment">// 使用Map作为数据模型，定义属性和值</span></span><br><span class="line">            Map&lt;String,Object&gt; model = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            model.put(<span class="string">&quot;myname&quot;</span>,<span class="string">&quot;Ray。&quot;</span>);</span><br><span class="line">            <span class="comment">// 传入数据模型到模板，替代模板中的占位符，并将模板转化为html字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">templateHtml</span> <span class="operator">=</span> FreeMarkerTemplateUtils.processTemplateIntoString(template1,model);</span><br><span class="line">            <span class="comment">// 该方法本质上还是发送html邮件，调用之前发送html邮件的方法</span></span><br><span class="line">            <span class="built_in">this</span>.sendHtmlMail(to, subject, templateHtml);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TemplateException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;发送邮件时发生异常！&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;发送邮件时发生异常！&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送带附件的邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAttachmentsMail</span><span class="params">(String to, String subject, String content, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="comment">//要带附件第二个参数设为true</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> filePath.substring(filePath.lastIndexOf(File.separator));</span><br><span class="line">            helper.addAttachment(fileName, file);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MessagingException e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;发送邮件时发生异常！&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MailUtils其实就是进一步封装Mail提供的JavaMailSender类，根据业务场景可以在工具类里面添加对应的方法，这里提供了发送文本邮件、html邮件、模板邮件、附件邮件的方法。</p>
<h1 id="四、Controller层的实现"><a href="#四、Controller层的实现" class="headerlink" title="四、Controller层的实现"></a>四、Controller层的实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;邮件管理&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailUtils mailUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送注册验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;发送注册验证码&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        mailUtils.sendSimpleMail(<span class="string">&quot;ruiyeclub@foxmail.com&quot;</span>,<span class="string">&quot;普通文本邮件&quot;</span>,<span class="string">&quot;普通文本邮件内容&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送注册验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;发送注册验证码&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendHtml&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendTemplateMail</span><span class="params">()</span>&#123;</span><br><span class="line">        mailUtils.sendHtmlMail(<span class="string">&quot;ruiyeclub@foxmail.com&quot;</span>,<span class="string">&quot;一封html测试邮件&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&lt;div style=\&quot;text-align: center;position: absolute;\&quot; &gt;\n&quot;</span></span><br><span class="line">                        +<span class="string">&quot;&lt;h3&gt;\&quot;一封html测试邮件\&quot;&lt;/h3&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;div&gt;一封html测试邮件&lt;/div&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;发送html模板邮件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        mailUtils.sendTemplateMail(<span class="string">&quot;ruiyeclub@foxmail.com&quot;</span>, <span class="string">&quot;基于模板的html邮件&quot;</span>, <span class="string">&quot;hello.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;发送带附件的邮件&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendAttachmentsMail&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendAttachmentsMail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\projects\\springboot\\template.png&quot;</span>;</span><br><span class="line">        mailUtils.sendAttachmentsMail(<span class="string">&quot;xxxx@xx.com&quot;</span>, <span class="string">&quot;带附件的邮件&quot;</span>, <span class="string">&quot;邮件中有附件&quot;</span>, filePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便测试，这里使用了swagger3，详情可以查看<a href="SpringBoot%E6%95%B4%E5%90%88Swagger3%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3">SpringBoot整合Swagger3生成接口文档</a>。</p>
<p>发送模板邮件这里，会读取resources下面的templates文件夹，测试中读取的是hello.html，具体代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>freemarker简单示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Freemarker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is $&#123;myname&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="五、测试结果"><a href="#五、测试结果" class="headerlink" title="五、测试结果"></a>五、测试结果</h1><p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/ce977f2c1c55d0f5c49f0d863f0eda89.png" alt="image.png"><br>如果需要达到通过邮件发送验证码的功能，可以使用redis。后台随机生成验证码，然后把用户的主键设为key，验证码的内容设为value，还可以设置个60s过期存储，发送成功后，用户登录通过主键从redis拿到对应的验证码，然后再进行登录验证就好了。</p>
<blockquote>
<p>参考链接：[Spring Boot整合邮件配置](Spring Boot整合邮件配置)</p>
</blockquote>
<p>GitHub地址：<a href="https://github.com/ruiyeclub/SpringBoot-Hello">https://github.com/ruiyeclub/SpringBoot-Hello</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Shiro实现登录拦截以及认证授权功能</title>
    <url>/2022/02/11/SpringBoot%E6%95%B4%E5%90%88Shiro%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="一、Shiro是什么？"><a href="#一、Shiro是什么？" class="headerlink" title="一、Shiro是什么？"></a>一、Shiro是什么？</h2><p>Apache Shiro是一个Java安全权限框框架。</p>
<p>Shiro可以非常容易的开发出足够好的应用，其不仅可以在javaEE环境。</p>
<p>Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。</p>
<h2 id="二、Shiro工作原理"><a href="#二、Shiro工作原理" class="headerlink" title="二、Shiro工作原理"></a>二、Shiro工作原理</h2><p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/eb29de36230aeb29dcc9257948081472.png" alt="image.png"><br>应用代码的交互对象是 “Subject”，该对象代表了<strong>当前 “用户”</strong>，而所有用户的安全操作都会交给 SecurityManager 来管理，而管理过程中会从 Realm 中获取用户对应的角色和权限，可以把 Realm 堪称是安全数据源。</p>
<p>也就是说，我们要使用最简单的 Shiro 应用：</p>
<ul>
<li>通过 Subject 来进行认证和授权，而 Subject 又委托给了 SecurityManager 进行管理</li>
<li>我们需要给 SecurityManager 注入 Realm 以便其获取用户和权限进行判断</li>
<li>也即，Shiro 不提供用户和权限的维护，需要由开发者自行通过 Realm 注入</li>
</ul>
<h2 id="三、SpringBoot整合Shiro"><a href="#三、SpringBoot整合Shiro" class="headerlink" title="三、SpringBoot整合Shiro"></a>三、SpringBoot整合Shiro</h2><p>1.xml导入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.config目录下创建ShiroConfig.java，拦截以及授权等功能都在这里配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建realm对象 需要自定义</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRealm <span class="title function_">userRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRealm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.DefaultWebSecurityManager</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;securityManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(<span class="meta">@Qualifier(&quot;userRealm&quot;)</span> UserRealm userRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//关联UserRealm</span></span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.ShiroFilterFactoryBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span>DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置安全管理器</span></span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加shiro的内置过滤器</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * anon：无需认证就可以访问</span></span><br><span class="line"><span class="comment">         * authc：必须认证了才能访问</span></span><br><span class="line"><span class="comment">         * user：必须拥有 记住我 功能才能用</span></span><br><span class="line"><span class="comment">         * perms：拥有对某个资源的权限才能访问</span></span><br><span class="line"><span class="comment">         * role：拥有某个角色权限才能访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; filterMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//授权</span></span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/add&quot;</span>,<span class="string">&quot;perms[user:add]&quot;</span>); <span class="comment">//进入需要授权（授权规则用户后面接：add）才可以进入add</span></span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/update&quot;</span>,<span class="string">&quot;perms[user:update]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截功能</span></span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/*&quot;</span>,<span class="string">&quot;authc&quot;</span>); <span class="comment">//表示访问user接口的资源都要认证</span></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//******处理权限不够或者需要授权的业务********</span></span><br><span class="line">        <span class="comment">//如果没有权限authc 设置登录的请求</span></span><br><span class="line">        bean.setLoginUrl(<span class="string">&quot;/toLogin&quot;</span>);</span><br><span class="line">        <span class="comment">//未授权页面</span></span><br><span class="line">        bean.setUnauthorizedUrl(<span class="string">&quot;/noauth&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.自定义UserRealm类，继承AuthorizingRealm重写用户授权和用户认证的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;<span class="comment">//用户授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line"><span class="comment">//        info.addStringPermission(&quot;user:add&quot;); 手动添加了权限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到当前登录的这个对象</span></span><br><span class="line">        Subject subject= SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> (User) subject.getPrincipal(); <span class="comment">//拿到user对象 可以设置用户权限</span></span><br><span class="line">        <span class="comment">//设置当前用户的权限 从数据库上面拿</span></span><br><span class="line">        info.addStringPermission(currentUser.getPerms());</span><br><span class="line">        System.out.println(currentUser.getPerms());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">userToken</span> <span class="operator">=</span> (UsernamePasswordToken) token;</span><br><span class="line">        <span class="comment">//认证用户（连接数据库）</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.queryUserByName(userToken.getUsername());</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//UnknownAccountException</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断session是否有值，显示登录按钮</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">currentSubject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> currentSubject.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以加密：MD5 MD5盐值加密（更高级）</span></span><br><span class="line">        <span class="comment">//密码认证（shiro完成）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user,user.getPassword(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shiro大致的配置就在这里了，具体功能如拦截功能、授权认证功能，可以在我的<br>github <a href="https://github.com/ruiyeclub/SpringBoot-Hello">https://github.com/ruiyeclub/SpringBoot-Hello</a>，进行查看。</p>
<p>Shiro核心概述可参考文章：<a href="https://www.cnblogs.com/deng-cc/p/9401900.html">https://www.cnblogs.com/deng-cc/p/9401900.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Swagger3生成接口文档</title>
    <url>/2022/06/01/SpringBoot%E6%95%B4%E5%90%88Swagger3%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>　　前后端分离的项目，接口文档的存在十分重要。与手动编写接口文档不同，swagger是一个自动生成接口文档的工具，在需求不断变更的开发环境下，手动编写文档的效率实在太低。与新版的swagger3相比swagger2配置更少，使用更加方便。</p>
<h1 id="一、pom文件中引入Swagger3依赖"><a href="#一、pom文件中引入Swagger3依赖" class="headerlink" title="一、pom文件中引入Swagger3依赖"></a>一、pom文件中引入Swagger3依赖</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="二、Application上面加入-EnableOpenApi注解"><a href="#二、Application上面加入-EnableOpenApi注解" class="headerlink" title="二、Application上面加入@EnableOpenApi注解"></a>二、Application上面加入@EnableOpenApi注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableOpenApi</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;cn.ruiyeclub.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger3Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Swagger3Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、Swagger3Config的配置"><a href="#三、Swagger3Config的配置" class="headerlink" title="三、Swagger3Config的配置"></a>三、Swagger3Config的配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger3Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.OAS_30)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;Swagger3接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;更多请咨询服务开发者Ray。&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;Ray。&quot;</span>, <span class="string">&quot;http://www.ruiyeclub.cn&quot;</span>, <span class="string">&quot;ruiyeclub@foxmail.com&quot;</span>))</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、Swagger注解的使用说明"><a href="#四、Swagger注解的使用说明" class="headerlink" title="四、Swagger注解的使用说明"></a>四、Swagger注解的使用说明</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>：用在请求的类上，表示对类的说明</span><br><span class="line">    tags=<span class="string">&quot;说明该类的作用，可以在UI界面上看到的注解&quot;</span></span><br><span class="line">    value=<span class="string">&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation</span>：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">    value=<span class="string">&quot;说明方法的用途、作用&quot;</span></span><br><span class="line">    notes=<span class="string">&quot;方法的备注说明&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiImplicitParams</span>：用在请求的方法上，表示一组参数说明</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>：用在<span class="meta">@ApiImplicitParams</span>注解中，指定一个请求参数的各个方面</span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        required：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：<span class="meta">@RequestHeader</span></span><br><span class="line">            · query --&gt; 请求参数的获取：<span class="meta">@RequestParam</span></span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：<span class="meta">@PathVariable</span></span><br><span class="line">            · body（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认String，其它值dataType=<span class="string">&quot;Integer&quot;</span>       </span><br><span class="line">        defaultValue：参数的默认值</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiResponses</span>：用在请求的方法上，表示一组响应</span><br><span class="line">    <span class="meta">@ApiResponse</span>：用在<span class="meta">@ApiResponses</span>中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如<span class="number">400</span></span><br><span class="line">        message：信息，例如<span class="string">&quot;请求参数没填好&quot;</span></span><br><span class="line">        response：抛出异常的类</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel</span>：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用<span class="meta">@RequestBody</span>这样的场景，</span><br><span class="line">            请求参数无法使用<span class="meta">@ApiImplicitParam</span>注解进行描述的时候）</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>
<p>Controller层的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;用户信息管理&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;userRecord&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRecordController</span> <span class="keyword">extends</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserRecordService userRecordService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询所有数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page       分页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userRecord 查询实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;分页查询所有数据&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">selectAll</span><span class="params">(Page&lt;UserRecord&gt; page, UserRecord userRecord)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="built_in">this</span>.userRecordService.page(page, <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;(userRecord)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过主键查询单条数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单条数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;通过主键查询单条数据&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">selectOne</span><span class="params">(<span class="meta">@PathVariable</span> Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="built_in">this</span>.userRecordService.getById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userRecord 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新增结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增数据&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> UserRecord userRecord)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="built_in">this</span>.userRecordService.save(userRecord));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userRecord 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;修改数据&quot;)</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> UserRecord userRecord)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="built_in">this</span>.userRecordService.updateById(userRecord));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键结合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除数据&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam(&quot;idList&quot;)</span> List&lt;Long&gt; idList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="built_in">this</span>.userRecordService.removeByIds(idList));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、Swagger界面效果"><a href="#五、Swagger界面效果" class="headerlink" title="五、Swagger界面效果"></a>五、Swagger界面效果</h1><p><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/2954ce2fd4c4dca470dc4cafd38e2fc3.png" alt="image.png"></p>
<p> Swagger的访问路径由port&#x2F;swagger-ui.html改成了port&#x2F;swagger-ui&#x2F; 或port&#x2F;swagger-ui&#x2F;index.html</p>
<blockquote>
<p>GitHub地址：<a href="https://github.com/ruiyeclub/SpringBoot-Hello">https://github.com/ruiyeclub/SpringBoot-Hello</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>SpringCloud使用Feign服务通信踩的坑</title>
    <url>/2022/06/01/SpringCloud%E4%BD%BF%E7%94%A8Feign%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>　　<strong>fallback熔断器实现了Feign客户端的所有方法，当网络不通或者访问失败时，会自动调用fallback服务降级类中的方法。</strong></p>
<p>启动项目时报错了，具体的报错信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: No fallback instance of type <span class="keyword">class</span> <span class="title class_">com</span>.xxx.xxx.feign.fallback.RemoteUserFallback found <span class="keyword">for</span> feign client xxx</span><br></pre></td></tr></table></figure>

<p>报错内容明显是没找到RemoteUserFallBack这个类</p>
<p>1、检查配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true # 开启Feign的熔断功能 默认是关闭的</span><br></pre></td></tr></table></figure>
<p>2、启动类上需要@EnableFeignClients注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.xxx.包名&quot;&#125;)</span> <span class="comment">//开启Feign并扫描Feign客户端</span></span><br></pre></td></tr></table></figure>

<p>3、Feign客户端类上使用@FeignClient，通过fallback属性来指明对应熔断器的类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;服务名&quot;, fallback = RemoteUserFallback.class,)</span> <span class="comment">//声明当前类是一个Feign客户端，并指定请求的服务名</span></span><br></pre></td></tr></table></figure>
<p><strong>4、fallback熔断器类上需要加注解@Component，确保可以被spring扫描</strong></p>
<p>我报错的原因就是出现在第四步这里，尽管我加了@component注解。SpringBoot在启动的时候 会扫描main类所在包及其子包进行Bean的实例化，但是fallback熔断器类并不在我启动类的子类下面，我这里是通过引入其模块来调用这里面的方法。</p>
<p>所以最后我在启动类上加了@ComponentScan注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.xxx&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<p>OK，成功启动并访问成功。</p>
]]></content>
  </entry>
  <entry>
    <title>启动项目报错Correct the classpath of your application so that it contains a single, compatible version of xxx</title>
    <url>/2022/02/13/%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99Correct%20the%20classpath%20of%20your%20application%20so%20that%20it%20contains%20a%20single,%20compatible%20version%20of%20xxx/</url>
    <content><![CDATA[<p>项目是基于Gradle构建的，在整合swagger后，启动项目时报错了。报错日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">An attempt was made to call a method that does not exist. The attempt was made from the following location:</span><br><span class="line"></span><br><span class="line">    springfox.documentation.spring.web.plugins.DocumentationPluginsManager.createContextBuilder(DocumentationPluginsManager.java:<span class="number">152</span>)</span><br><span class="line"></span><br><span class="line">The following method did not exist:</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;org.springframework.plugin.core.Plugin org.springframework.plugin.core.PluginRegistry.getPluginFor(java.lang.Object, org.springframework.plugin.core.Plugin)&#x27;</span></span><br><span class="line"></span><br><span class="line">The method<span class="string">&#x27;s class, org.springframework.plugin.core.PluginRegistry, is available from the following locations:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    jar:file:/C:/Users/Administrator/.gradle/caches/modules-2/files-2.1/org.springframework.plugin/spring-plugin-core/2.0.0.RELEASE/95fc8c13037630f4aba9c51141f535becec00fe6/spring-plugin-core-2.0.0.RELEASE.jar!/org/springframework/plugin/core/PluginRegistry.class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It was loaded from the following location:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file:/C:/Users/Administrator/.gradle/caches/modules-2/files-2.1/org.springframework.plugin/spring-plugin-core/2.0.0.RELEASE/95fc8c13037630f4aba9c51141f535becec00fe6/spring-plugin-core-2.0.0.RELEASE.jar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Action:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Correct the classpath of your application so that it contains a single, compatible version of org.springframework.plugin.core.PluginRegistry</span></span><br></pre></td></tr></table></figure>
<p>百度之后，发现是jar包冲突了，导入了两个不同版本的jar包。如图：<br><img src="https://ruiyeclub.oss-cn-shenzhen.aliyuncs.com/articles/a3688f4401c04f3a53efb72e701a4457.png" alt="image.png"><br>解决办法可以直接将依赖中的jar包剔除掉，或者直接删除该依赖也行。</p>
]]></content>
  </entry>
</search>
